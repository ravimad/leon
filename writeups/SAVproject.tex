\documentclass[a4paper,10pt]{article}
\begin{document}
\title{SAV project proposal \\ Templates in Function Postconditions}
\author{Ravichandhran Kandhadai Madhavan}
\maketitle

\newcommand{\dash}[1]{\overline{#1}}

\section{Problem Definition}

The goal of the project is to (a) enable the use of (quantifier-free) linear templates with unknown coefficients in the postconditions and (b) to develop an inference engine for finding an instantiation of the linear template that is inductive. In this project, I will focus only on Leon programs that can be expressed as linear transition systems. In such programs every primitive expression is a linear combination of program variables and function invocations. However, the programs may have \textit{if-then-else} constructs and \textit{let} constructs. Also, every expression in the program is of type \textit{Int}.
%The freedom to specify such templates in post-conditions will greatly reduce the annotation burden of the programmer.
The templates in the postconditions can use all the program variables visible in the postconditions (viz. parameters and result variable) and also user-defined functions. Formally, a template is an expression of the form $a_0 + a_1x_1 + a_2x_2 + \cdots + a_nx_n \le 0$ where each $x_i$ is a program variable or function symbol and each $a_i$ is a unknown coefficient (referred to as a \textit{template variable}) or a constant.

\section{The Approach}

The plan is to use the approach discussed in \cite{ssriram:CAV03,ssriram:SAS04} that uses non-linear constraint solving for finding the instantiations of the templates. Consider a function (belonging to the above restricted language) whose post-condition uses templates. Assume that the post-condition is a single atomic predicate. The verification condition computed by Leon for the function would be of the form: $\varphi: \bigwedge_i \varphi_i$, where,
$\mathit{\varphi_i: } \forall \dash{x}. \phi[\dash{x},\dash{a}] \Rightarrow p[\dash{x},\dash{a}]$, $\dash{x}$ is a set of program variables, $\dash{a}$ is a set of template variables, $\phi$ is a conjunction of linear atomic predicates defined over the program and template variables and $p$ is a single atomic predicate.
The goal is to find an assignment to $\dash{a}$ such that $\varphi$ holds.
As described in \cite{ssriram:CAV03}, by \textit{Farka's Lemma}, the values of $\dash{a}$ that satisfy $\varphi$ can be obtained by solving a system of non-linear real valued inequalities generated from $\varphi$. To solve the inequalities, the plan is to use the Z3 SMT solver integrated into Leon.

Allowing conjunctions in the postcondition is straight-forward as the generated  verification condition could translated to the above form given by $\varphi$. However, supporting disjunctions in the postcondition is challenging as the verification condition generated by Leon cannot be directly reduced to form given by $\varphi$. In such cases, the plan is to construct a formulae of the form given by $\varphi$ that is stronger than the verification condition.

In addition to implementing the above approach, I plan to extend it to handle templates with user-defined functions using the ideas presented in \cite{dirk:VMCAI07}. Also, I would like to combine this approach with the function unrolling mechanism of Leon to discover invariants that requires reasoning about multiple procedures.
 
\section{Completeness of the approach}

There are two sources of incompleteness: (a) Farka's Lemma is incomplete for integer arithmetic. There exists templates with instantiations that are  inductive which cannot be found by the proposed approach. (b) Handling of disjunctions in the postconditions also introduces incompleteness.
As a part of the project I also plan to study and characterize formulas (of the form given by $\varphi$) for which Farka's Lemma may be incomplete.

\section{Deliverables}

An enhanced Leon verifier that can support linear templates in postconditions. Ideally, it should be able to handle all linear transition systems when expressed as Leon programs.

\bibliographystyle{acm}
\bibliography{SAVproject}

\end{document}