\section{Preliminaries}

\paragraph{The Language.}

\begin{figure}
\begin{align*}
ADT \rightarrow  & \tau := Cons \\
Cons \rightarrow & con(fd_1 : \tau_1,\cdots,fd_n : \tau_n); \; Cons \\
\end{align*}
\caption{Syntax of the algebraic data types. In the above, $\tau,\tau_1, \cdots, \tau_n \in \typesyms$;
$con \in \consyms$ and $fd_1,\cdots,fd_n \in \fdsyms$ } \label{fig:type-syntax}
\end{figure}
%
\begin{figure}
\begin{align*}
Proc \rightarrow & \text{ def P}(v_1 : \tau_1,\cdots,v_n : \tau_n) : \tau \{ \; E_1 \; \}  \\
E \rightarrow &  v \in \vars \vbar c \in \consts \vbar \text{ let } v := E_1 \text{ in } E_2 \vbar E_1 \; \op \; E_2 \\
				 & \vbar if(E_1) \; E_2 \; else \; E_3 \vbar F(v_1,\cdots,v_n) \vbar assume(E_1) \; E_2 \\
				 & \vbar v \text{ match } \{ con(v_1,\cdots,v_n) => E_1 \vbar \_ => E_2 \} \\ 
\end{align*}
\caption{Syntax of the procedures. In the above, $P,F \in \fsyms$; 
$v_1,\cdots,v_n \in \vars$; $\tau,\tau_1,\cdots,\tau_n \in \typesyms$; $con \in \consyms$} \label{fig:lang-syntax}
\end{figure}
%
We consider a pure \emph{first-order} language that supports algebraic data types,
integers, recursion and arithmetic, logical operations but doesn't allow any side-effects.
Figure~\ref{fig:type-syntax} shows the syntax of the algebraic data types.
$\typesyms$ is the set of type symbols which includes the names of the algebraic data 
types and $Int$.
If an ADT $x$ belongs to a constructor $con(\gamma: T,\cdots)$ then we say that 
$\gamma$ is a \emph{field} of $x$. Every constructor defines a set of fields of an ADT. 
Every constructor belonging to our language uses unique field names.  
$\consyms$ and $\fdsyms$ are the sets of constructor symbols and field symbols 
used in the program, respectively.

Figure~\ref{fig:lang-syntax} shows the syntax of the language.
%Note that our language is first-order i.e, functions are not treated as first class entities.
In the figure, $\op$ is a set of primitive operations.
The operations can be classified into $\relop$ relational operations viz. $\le,\ge,<,>,=$
and $\arthop$ arithmetic operations which are $+$,$-$ and $.$ (dot) which denotes a restricted
form of multiplication in which the first operand is a constant.
Many other operations like $*,/,exp,\log$ etc. can be implemented as (recursive) user defined functions
using the primitive operations.

$\fsyms$ is a set of function symbols which includes procedure names.
$\vars$ denotes a set of program variables and $\consts$ denote a set of constants.
A special variable called $res \in \vars$ is used to store the result of an expression (see
the semantics below).
The language supports a match construct with the usual semantics for performing pattern matching
on algebraic data types.

The language also supports an \textit{assume} statement which can be used to specify properties
that can be assumed to hold at a point in the program. 
Hence, preconditions can be specified using \textit{assume} statements. Therefore, we do not specially refer to
preconditions in the rest of the document.
For brevity we omit the typing rules. We only consider programs that are \emph{well typed}.

\paragraph{The Semantics.}

Define the semantic domains $store$ and $Val$ as follows: 
$store = \vars \mapsto Val_{\bot}$ is a mapping from variables to values (and $\bot$).
$Val = \integer \cup con(Val^n) \cup \emptyset$, where $con \in \consyms$, is the domain of values of 
the variables which includes integers and instances of algebraic data types.
The concrete semantics of an expression $E$, denoted as $\concsem{E}$, is a function in
$store \mapsto store$. Given a store $\sigma$, the result of the evaluation
of the expression $E$ is given by $\concsem{E}(\sigma)(res)$.
For brevity, we also omit the detailed semantic description of the language constructs.

\paragraph{The Post Conditions.}

A post condition of a procedure $P$ is a \emph{boolean valued} expression belonging to our language
that is defined over the formal parameters of $P$ and a special variable $res$ which represents 
the return value of the procedure. 

\paragraph{The Logic.}

\begin{figure}
\begin{align*}
Atom  \rightarrow & v \in \lvars \vbar c \in \consts \vbar Atom_1 \; \op \; Atom_2  \vbar  & \\
				  & FuncAtom \vbar InstAtom \vbar FieldAtom & \\
FuncAtom  \rightarrow & f(Atom_1,\cdots,Atom_n) & \text{ where } f \in \fsyms, n \in \nat   \\
InstAtom  \rightarrow & Atom \instOf con 		& \text{ where } con \in \consyms \\				 
FieldAtom \rightarrow & Atom.\field 			& \text{ where } \field \in \fdsyms \\
Pred \rightarrow & Atom \vbar Pred_1 \vee Pred_2 \vbar Pred_1 \wedge Pred_2 \vbar \neg Pred & 
\end{align*}
\caption{Syntax of the formulas belonging to the logic.} \label{fig:logic-syntax}
\end{figure}
%
Figure~\ref{fig:logic-syntax} shows the syntax of the logical formulas we work with. 
In the figure, $Atom$ stands for an \emph{atomic predicate}, $Pred$ for 
a \emph{predicate}. $\op$ is a set of binary operations. We assume that the logic 
supports all the primitive operations supported by the language. 
$\lvars$ is a set of logical variables which includes all the program variables and may also 
include other logical variables. 

A $FuncAtom$ is an application of a user defined function. The logic
treats this as an uninterpreted function application. In other words, $\fsyms$ is
treated in the logic as a set of uninterpreted function symbols.
References to a field $\field$ of an algebraic data type $x$ is represented as $x.\field$.
%(see Figure~\ref{fig:vc} for more details).

$\instOf: Atom \times \consyms$ is  an \emph{instance of} operator that checks 
if a given atomic predicate is an instance of the given constructor.
$\alpha \instOf con$ evaluates to true only when $\alpha$ is an algebraic data type 
and $\alpha$ is an instance of $con$.

As in the common practice, we use, $A \imp B$ as a short hand for $\neg A \vee B$,
the term \textit{Disjunct} to refer to a  formula of the form $\bigwedge a_i$ where $a_i \in Atom$
and the term \textit{Conjunct} to refer a formula of the form $\bigvee a_i$, $a_i \in Atom$.
Our logic does not support any quantifiers.

Assume that there exists a procedure for deciding the satisfiablity of the formulas 
belonging to the above logic.

\paragraph{Verification Condition Generation.}

Let $T$ be a mapping from a procedure to its post-condition.
We now describe how to convert a procedure $P$ and its post-condition to a formula 
such that the procedure satisfies its post-condition iff the formula is valid. 
This formula is referred to as the verification condition and denoted as $\vc(P,T)$.

Define a function $\tr{T}: E \mapsto 2^{Pred \times Atom}$ 
that, given a mapping $T$ from procedures to post conditions, 
maps an expression belonging to our language to a set of predicate, atom pairs. 
Each entry $(\guard,\val)$ in $\tr{T}(E)$ implies that under the guard $\guard$,
$E$ evaluates to $\val$.
Figure~\ref{fig:vc} defines the function $\tr{}$.

\begin{figure}
\begin{center}
\begin{tabular}{|l|l|}
\hline
$Expr$ & $\tr{T}(Expr)$  \\ \hline
$v\in \vars$ 					& $\{ (true,v) \}$ \\
$c \in \consts$ 					& $\{ (true,c) \}$ \\
$E_1 \; \op \; E_2$ & 
$\{ (\guard_1 \wedge \guard_2, \val_1 \; \op \; \val_2) \}$  \\
%\vbar (\guard_1,\val_1) \in \tr{T}(E_1), (\guard_2,\val_2) \in \tr{T}(E_2) \}$ \\
%								
let $x := E_1$  in $E_2$  & 
 $\{ (\guard_1 \wedge \guard_2[\val_1/x],\val_2[\val_1/x]) \}$  \\
% \vbar (\guard_1,\val_1) \in \tr{T}(E_1), (\guard_2,\val_2) \in \tr{T}(E_2) \}$  \\
%		
$if(C) \; E_1 \; else \; E_2$ &
 $\{ (\guard_c \wedge \val_c \wedge \guard_1, \val_1) \} \cup 
 \{ (\guard_c \wedge \neg \val_c \wedge \guard_2, \val_2) \}$ \\
% \vbar (\guard_1,\val_1) \in \tr{T}(C), (\guard_2,\val_2) \in \tr{T}(E_1), (\guard_3,\val_3) \in \tr{T}(E_2) \}$  \\
%
$S: F(\tup{V})$ & 
	$\{ (\pop{S}(\guard)[F(\tup{V})/res] \wedge \pop{S}(\val)[F(\tup{V})/res], F(\tup{V}))$ \\
	& $\qquad \vbar (\guard,\val) \in \tr{T}(T(F)) \}$  \\
%
$assume(C) \; E_1$  &  
   $\{ (\guard_c \wedge \guard_1 \wedge \val_c, \val_1) \}$ \\
%   \vbar (\guard_1,\val_1) \in \tr{T}(C), (\guard_2,\val_2) \in \tr{T}(E) \}$  \\
%
$x \text{ match } \{ con(v)=> E_1 \vbar $ & 
		$\{ (x \instOf con \wedge \guard_1[x.\field/v], \val[x.\field/v]) \}$ \\ 
$\qquad \qquad \_ => E_2 \}$		& 
 		$\cup \{ (\neg (x \instOf con) \wedge \guard_2, \val_2)\} $ \\
%\vbar (\guard,\val) \in \tr{T}(E) \}$ \\
\hline
\end{tabular}
\end{center}
\caption{Definition of the function $\tr{}$. In the above
$(\guard_1,\val_1) \in \tr{T}(E_1)$, $(\guard_2,\val_2) \in \tr{T}(E_2)$, 
$(\guard_c,\val_c) \in \tr{T}(C)$, 
$\gamma$ is the field of $x$ defined by the constructor $con$.} \label{fig:vc}
\end{figure}
%
Given a call expression $S$, $\push{S}: Pred \mapsto Pred$ is the 
function that renames the actual arguments passed to the call $S$ by the formal parameters.
$\pop{S}: Pred \mapsto Pred$ is the inverse function that renames the formal parameters
to actual arguments of the call $S$.

Consider the handling of the match expression in Figure~\ref{fig:vc}. 
For brevity the figure defines $\tr{}$ only when the constructor used in the match 
expression has a single parameter. 
It is straight forward to extend this definition to multi-parameter constructors.

Let $B$ denote the body of the procedure which is an expression.
The verification condition $\vc(P,T)$ is defined as: 
%
\begin{align}
\vc(P,T) = \bigwedge_{(\guard_b,\val_b) \in \tr{T}(B), (\guard_p,\val_p) \in \tr{T}(P)} 
(\guard_b \wedge \guard_p \imp \val_p)[\val_b/res]
\end{align}
%
\begin{figure}
\begin{myprogram}
Tree := Emp() \\
\> \>   :=  N(x: Int, l: Tree, r: Tree) \\     
\\
s(t : Tree) : Int \{ \\
\pnl \> t match \{ \\
\pnl \> case Emp() => 0; \\
\pnl \> case N(x,l,r) => s(l) + s(r) + 1; \\
\> \} \\
\} ensuring(res => res != -1)
\end{myprogram}
\caption{A procedure that computes the size of a binary tree.} \label{fig:eg}
\end{figure}
%
Figure~\ref{fig:eg} shows an example program belonging to our language which we use as a running example.
The verification condition for this program is given below
%
\begin{align*}
& t \instOf Emp \imp 0 \ne -1 & \qquad (c_1)\\
& t \instOf N \wedge s(t.l) \ne -1 \wedge s(t.r) \ne -1 \imp s(t.l) + s(t.r) + 1 \ne -1 & \qquad (c_2) 
\end{align*}

%Note that the verification condition is an over approximation of the 
%behaviors of the procedure $P$ as it treats a called function as uninterpreted
%whose behaviors are restricted only by its specification. 
%The verification condition is defined over the theory of uninterpreted functions
%and the base theory $T$.  

%\paragraph{A Simpler Setting.}
%
%We now focus on a simpler (but equally expressive) setting that considers only a subset 
%of programs belonging to our language and describe an algorithm for this simpler setting. 
%
%(a) We only consider procedures in which all procedure calls are direct recursive calls.
%(b) We assume that the specifications do not contain any user-defined functions.
%
%Note that any program belonging to our language can be translated to this simpler setting.

\paragraph{The Problem.}

Let $T$ be a mapping from procedures to their post-conditions. $T$ is inductive w.r.t $P$ 
iff $\vc(P,T)$ is valid.

The inductive generalization problem is to find a formula $\rho$ such that:
$T'(P) = T(P) \wedge \rho$ and $\vc(P,T')$ is inductive.
We refer to $\rho$ as a strengthening predicate. 

\paragraph{Assumptions.}

We assume that the following hold. \\
(a) the post-condition $T(P)$ is disjunction free.  \\
(b) the strengthening predicate $\rho$ is disjunction free i.e, it is a conjunction of atomic predicates. \\
(c) every atomic predicate in $\rho$ is linear. Nevertheless, $\rho$ can have function symbols. 
E.g. $f(x) + g(y) \le 0$ is linear while $f(x).g(y) \le 0$ is non-linear, irrespective
of whether $f$ and $g$ are linear.

