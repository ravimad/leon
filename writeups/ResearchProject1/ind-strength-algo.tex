\section{The Inductive Strengthening Algorithm}

\begin{figure}
\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{Program $P$ and post-condition $T'(P)$} 
\Output{On termination, the inductive invariant that entails $T'(P)$ or a counter-example
violating the post-condition} 

\BlankLine
Let $CtrEx$ be a globally accessible set of counter-examples (elements of $store$) 
initialized to $\emptyset$\\

\SetKwFunction{SDecide}{SemiDecide}
\SetKwFunction{IndGen}{IndGen}
\SetKwFunction{Eliminate}{Eliminate}
\SetKwFunction{SG}{SplitAndGen}
\SetKwFunction{Simplify}{Simplify}

\IndGen{P,T'}
\Begin{

\nl $res$ = \SDecide{$P$,$T'$} \;
\tcp{$res$ can be $true$ implying that the post condition holds, 
it can be counter-example (an assignment to inputs of $P$ that makes the 
post condition fail) or $\bot$  implying that the procedure was unable to decide}

\nl \If{$res \ne \bot$} { 
    \nl \Return $res$ \; 
}
\nl Compute $\bigwedge_i c_i = \vc(P,T')$ \;
\nl \While{$true$} {
\nl Let $\iota$ be a formula initialized to $T'(P)$ \;
\nl \ForEach{$c_i$ in $\vc(P,T')$}
    {
   \nl \If{$c_i$ does not have a recursive call to $P$}{
       \nl Check validity of $c_i$ using the theory solver \;
       \nl \If{$c_i$ is not valid}{
         	Let $\sigma$ be a model that doesn't satisfy $c_i$ \;
         	
           \tcp{It is a counter-example for the post condition since $c_i$ corresponds to an unrolled path
           and not an over-approximation}
                      
           \nl \Return  $\sigma$ \;
        }
    }
   \nl \Else{          
       \nl $\psi$ = \SG{P,$c_i$,$CtrEx$} \;
       \tcp{\SG comes up with a strengthening predicate satisfying constraints (a)--(e)}       
       			  
	   \nl $\iota := \iota \wedge \psi$ \;
      }
   }
\nl \Simplify{$\iota$} \;
%\nl \If{ $\iota$ is same as the $\iota$ of previous iteration } {
%       \nl Return $\bot$ \;
%     }
\nl $r$ = \IndGen{P,$T'[P \mapsto \iota]$} \;
\nl If $r$ is $true$ return $r$ otherwise add $r$ to $CtrEx$ \;
}
}
\end{algorithm}
\caption{The inductive strengthening algorithm} \label{fig:indgen-algo}
\end{figure}

Figure~\ref{fig:indgen-algo} shows our inductive strengthening algorithm.
Let the verification condition $\vc(P,T)$ be in the CNF form i.e, 
$\vc(P,T) = \bigwedge_i c_i$. 
Note that each conjunct $c_i$ would be of the form $\phi_i \imp B_i$  
where $\phi_i$ is a conjunction of atomic predicates and $B_i$ is a single atomic predicate.
Intuitively, $\phi_i$ is the path condition of a (static) path in the 
program along which there can be one or more recursive calls to $P$.
$B_i$ corresponds to an atomic predicate in the post condition with $res$ replaced
by the result of the procedure along the static path represented by $\phi_i$.
As it can be seen in Figure~\ref{fig:indgen-algo}, the algorithm invokes the following 3 routines 
whose expected behavior is described below.

(a) The routine \SDecide is a (terminating) semi-decision procedure for validating the post-conditions
of a procedure $P$. It could either return $true$ implying that the post-condition does hold, it may return
a counter-example that violates the post-condition or it could return a $\bot$ indicating that it cannot 
decide. We require that if the post-condition is inductive then \SDecide returns $true$. 
Any non-terminating verifier (like \textit{Leon}) can be substituted for \SDecide by fixing a timeout 
and returning $\bot$ after the time-out.

The ability of \SDecide to find counter-examples efficiently (if they exist)
profoundly impacts the progress and hence termination of the \IndGen procedure.
Specifically, if \SDecide returns a $\bot$ even when there exists a counter-example 
then the algorithm will try strengthening an invalid post-condition and will never make any
progress towards the required inductive invariant.
In the future, we plan to investigate ways of relaxing this assumption and still guarantee progress.

For the running example, \SDecide will return $true$ when invoked on $(c_1)$ and 
may return $\bot$ when invoked on $(c_2)$ since $res \ne -1$ is not inductive.

(b) The \Simplify routine tries to simplify a formula whenever possible. We assume that this operation is 
semantic preserving.

(c) \SG (abbreviation of split and generalization). This is the most important 
routine that performs the actual generalization. We now discuss this in more detail.