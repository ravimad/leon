\section{Split and Generalization}

%\paragraph{Auxiliary functions.}

\begin{definition}
 $Atoms: Pred \mapsto 2^{Atom}$  is a function from a formula $\phi$ to 
 a set of atomic predicates in $\phi$. 
\end{definition}

\begin{definition}
$Arith: Atom \mapsto Bool$  is a function that returns $true$ if the atomic predicate $a$ 
is of the form $a_1 \op_1 \cdots \op_n a_n$ where $\op_1 \cdots op_n$ are arithmetic 
operations.
\end{definition}

\begin{definition}
 $\funcs: Pred \mapsto 2^{FuncAtom}$  is a function from a formula $\phi$ to 
 a set of functional atomic predicates ($FuncAtoms$) in $\phi$. 
\end{definition}

\begin{definition}
$\funcsym: FuncAtom \mapsto \fsyms$  is a mapping from a functional atom (a call) to 
its function symbol i.e, the procedure that is called.
\end{definition}

\begin{definition}
$\args: \fsyms \mapsto \vars^n$ is a function from a function symbol $F$ 
in the input program to the formal parameters of $F$.
\end{definition}

\begin{definition}
$\argmap: FuncAtom \mapsto (\vars^n \mapsto Atom^n)$  is a function that given a 
$FuncAtom$ of the form $F(a_1,\cdots,a_n)$ returns a mapping from the 
formal parameters of $F$ to the actual arguments.
Formally, $\argmap(F(a_1,\cdots,a_n)) = \{ (p_1,a_1),\cdots,(p_n,a_n) \}$,
where $(p_1,\cdots,p_n) = \args(F)$.
\end{definition}

\begin{definition}
$\push{}: Pred \times FuncAtom \mapsto Pred$  is a function defined as follows:
$\push{}(\phi,F(a_1,\cdots,a_n)) = \phi[p_1/a_1]\cdots [p_n/a_n]$,
where $\argmap(F(a_1,\cdots,a_n)) = \{ (p_1,a_1),\cdots,(p_n,a_n) \}$.
\end{definition}

\begin{definition}
Let $\decomp: Pred \mapsto E$ be a function that \emph{decompiles} a logical formula to 
a semantically equivalent expression belonging to our language.
$\decomp$ is a syntactic transformation that replaces the logical operations like $op$, $\vee$, $\wedge$,
$\neg$ in the input formula by the equivalent constructs belonging to our language.
\end{definition}

\paragraph{The Algorithm.}

\begin{figure}
\begin{algorithm}[H]
\SetKwFunction{hypervol}{FindHyperVolume}
\SetKwFunction{equivforms}{EquivForms}
\SetKwFunction{group}{Group}

\textbf{input: } A procedure $P$, a formula $\phi$ of the form $\pathc \imp B$, $B \in Atom$, 
a set of counter examples $CtrEx$  \\
\textbf{output: } A formula satisfying the constraints~(a)--(e)

\SG{$P$,$\phi$,$CtrEx$} \\
\Begin{	
	\nl Let $recfuncs = \{ f  \vbar f \in \funcs(\pathc) \wedge \funcsym(f) = P \}$ \;
    \nl $S = \equivforms(\pathc \imp B)$ ; \tcp{$S$ is a disjunct}
    \nl $splits = \emptyset$ \;
    \nl \ForEach {$\alpha$ in $S$}{
    	\tcp{ see the specifications of \group }
    	\nl  $(\alpha',\Lambda,M) = \group(\alpha,recfuncs)$ \;    	
      		\nl $\psi = true$ \;
      		\nl Let $dom(\Lambda) = \{t_1,\cdots,t_k \}$ \;
      		\nl $\Lambda' = \{ \push{}(\Lambda(t),M(t)) \vbar t \in dom(\Lambda) \}$ \;
      		
      		\BlankLine 
      		\nl Let $\mu: temps \mapsto 2^{Val}$ be initialized to $\emptyset$ \;
			\nl \For{$j = 1$ to $|CtrEx|$} {
			  \nl Let $\sigma$ be the $j^{th}$ counter-example in $CtrEx$ \;
			  \nl \For{$1 \le i \le k$} {
 			    	\nl Let $\mu(t_i) = \mu(t_i) \cup \concsem{\decomp(\Lambda'(t_i))}(\sigma)$ \; 			    			
 			   	  }
			}
      		\nl \For{$a \in Atoms(\alpha')$}{
      			\nl \If{$\fv(a) = \{ t \}$ where $t \in dom(\Lambda)$}{
      				\nl $\psi = \psi \wedge a$ \;
      			}
      			\nl \ElseIf{$Arith(a)$}{      				
      				\nl $temps = \fv(a) \cap dom(\Lambda)$  \;     																 	 					\tcp{see the specifications of \hypervol}
 		 			\nl $\pi = \hypervol(a,temps,\mu)$ \;
 		 			\nl $\psi = \psi \wedge \pi$ \; 		 			
      			}      			
      			\nl \Else{
      				\nl $\psi = false$ \;
      				\nl break \;
      			}
      		}             		
 		 	\nl $\psi' = \psi[\Lambda'(t_1)/t_1]\cdots[\Lambda'(t_k)/t_k]$ \; 				 	
      		\nl $splits = splits \cup \{ \psi' \}$\;          			      		
	}
	\nl Let $\psi \in splits$ s.t. $\neg (\exists \pi \in splits \wedge \psi \imp \pi)$ \;
	\nl \Return $\psi$ \;	
}
\end{algorithm}
\caption{Algorithm for Split and generalization.} \label{fig:splitgen-algo}
\end{figure}
%
Figure~\ref{fig:splitgen-algo} shows the algorithm for splitting and generalization.
The following is its I/O specification.

It takes as input a procedure $P$, a conjunct that is of the form $\pathc \imp B$, 
where $\pathc$ is a path-condition and $B$ is an atomic predicate (see Figure~\ref{fig:indgen-algo}), 
and a set of counter-examples $CtrEx$.
It is required to produce a formula $\psi$ such that the following conditions holds. \\

\begin{tabular}{cl}
(a) & $\psi$ is linear and disjunction free \\

(b) & $\fv(\psi) \subseteq \args(P) \cup \{ res \}$. \\

(c) & $\bigwedge_{f \in R} \push{}(\psi,f) \wedge \pathc \imp B$, 
where $R$ is the set of recursive calls in $\pathc$ \\
& \ie{} $R = \{ f \in \funcs(\pathc) \vbar \funcsym(f) = P \}$. \\

(d) & For all $\sigma \in CtrEx$, $\concsem{P}(\sigma) \models \psi$ \ie{}, 
concretely evaluating $P$ on $\sigma$ satisfies $\psi$. \\

(e) & $\psi$ is minimal i.e, there does not exist a $\pi$ satisfying the above properties \\
& s.t. $\bigwedge_{f \in R} \push{}(\psi,f) \imp \bigwedge_{f \in R} \push{}(\pi,f)$  \\
\end{tabular} \\

The routine \equivforms used in the algorithm returns a set of \emph{disjuncts} equivalent to $B$
(including $B$ itself) when the path condition $\pathc$ holds. 
Formally, for every $x \in \equivforms(\pathc,B)$, $\pathc \imp B$ is equivalent to $\pathc \imp x$. 
However, $\equivforms$ need not necessarily return all such disjuncts $x$ (there may be infinitely many of them). 
We present a definition of this procedure towards the end of the section.

\begin{figure}
\begin{algorithm}[H]
\SetKwFunction{expressible}{Expressible}
\textbf{input: } A disjunct $\alpha$  \\
\textbf{output: } A triple described by (f)--(h) \\

\group{$\alpha$,$funcs$}
\Begin{	
\nl Let $\alpha' = true$ \;
\nl Let $\Lambda = \emptyset, M = \emptyset$ \;
\nl \For{$a \in Atoms(\alpha')$}{
	\nl Let $funcs = \{ fa_1,fa_2,\cdots,fa_n \}$ \;
	\nl Let $\alpha = a_1 \; \op_1 \; \cdots \; \op_{m-1} \; a_m $ \;
%	\tcp{ $\op_1, \cdots,\op_n$ are either $+/-$ } 
	
	\nl Let $G = (V_1,V_2,E)$ be a bipartite graph \;
	\nl Let $V_1 = \{ a_i \vbar 1 \le i \le m\}$, $V_2 = funcs$ \;
	
	\nl \For{$j = 1$ to $n$} {
		\nl \For{$i = 1$ to $m$} {
	    	\nl \If{$\expressible(a_i,\args(fa_j))$} {
      			\nl $E = E \cup \{ (a_i,fa_j) \}$ \;
       		 }
        }
    }    
    \nl Let $V_s \subseteq V_1$ be a set of isolated atoms \;
        
    \nl Let $\mu: (V_1 \setminus V_s) \mapsto V_2$ be a function s.t
    $(u,\mu(u)) \in E$ and $range(M)$ is minimized.
    Let $\inv{\mu}: V_2 \mapsto 2^{V_1}$ be the inverse function \;
    
	\BlankLine    
    \nl Let $\{ h_1,\cdots,h_k \} = range(\mu)$ \;    
    \nl Let $\{ t_i, 1 \le i \le k \}$ be a set of fresh variables one for each $h_i$ \;
    \nl $M = M \cup \{ (t_i,h_i) \vbar 1 \le i \le k \}$ \;
    
    \BlankLine
    \nl Express $a$ as 
    $g_1(\inv{\mu}(h_1)) \; \op'_1 \cdots \op'_k \; g_k(\inv{\mu}(h_k)) \; \op'_{k+1} \; g_{k+1}(V_s) \; \relop \; 0 $\;
    \nl $\Lambda = \Lambda \cup \{ (t_i,g_i(\inv{\mu}(h_i)) \vbar 1 \le i \le k \}$ \;
  }
  \nl Let $\alpha' = \alpha[t_1/\Lambda(t_1)]\cdots [t_m/\Lambda(t_m)]$,
  where, $Dom(\Lambda) = \{ t_1,\cdots,t_m \}$ \;
  \Return $(\alpha',\Lambda,M)$\;
}
\end{algorithm}
\caption{Algorithm for grouping.} \label{fig:group-algo}
\end{figure}
%
Consider the routine \group invoked by the \SG algorithm on every element of $S$. 
Figure~\ref{fig:group-algo} presents a detailed algorithm for \group.
The \group routine takes as input a disjunct $\alpha$ and a set of functions $funcs$
(in this case they are recursive calls to $P$ in the path-condition) and returns a triple
described below. 

(f) A function $M$ mapping a set of fresh variables to a set of functions in $funcs$. 

(g) A function $\Lambda$ mapping each fresh variable $t$ to a formula \emph{expressible} 
in terms of the arguments of the function $M(t)$. 

(h) A disjunct $\alpha'$ having the set of fresh variables as free variables, such that, 
when each fresh variable is replaced by its image in $\Lambda$ a formula equivalent to $\alpha$ is obtained.

\begin{figure}
\begin{algorithm}[H]
\textbf{input: } a formula $\phi$ and a set of atoms $Atoms$. \\
\textbf{output: } $true$ if the formula is expressible in terms of the atoms. \\
\expressible{$\phi$,$Atoms$}
\Begin{	
	\nl Let $Atoms = \{ a_1,\cdots,a_n \}$ \;
	\nl Let $temps = \{ t_1, \cdots, t_n \}$ be a set of fresh variables \;
	\nl Let $\phi' = \phi[t_1/a_1]\cdots [t_n/a_n]$ \;
	\nl \If{$\fv(\phi') \subseteq temps$} {
		\nl \Return $true$ \;
	}
	\nl \Return $false$ \;
}
\end{algorithm}
\caption{Algorithm that checks if a formula is expressible in terms of a set of atoms.} 
\label{fig:express-algo}
\end{figure}
%
In general, given a set of atoms, a formula is \emph{expressible} in terms of the given atoms iff 
there exists an equivalent formula in terms of the atoms belonging to the set.
However, determining this is very expensive.
Therefore, as an approximation, we use the routine \expressible shown in Figure~\ref{fig:express-algo} 
that defines a more restricted notion of expressibility.

For the running example, when \group is invoked on the atom $s(t.l) + s(t.r) + 1 \ne -1$ with 
$funcs = \{ s(t.l), s(t.r) \}$,
it would return the following triple $(\alpha',\Lambda,M)$, where, $\alpha' = t_1 + t_2 + 1 \ne -1$,
$\Lambda = M = \{ (t_1,s(t.l)), (t_2,s(t.r)) \}$, $t_1$ and $t_2$ are fresh variables.

As another example, consider the atomic predicate $h(l,i) - i + h(r,j) \ne 0$ and let 
$funcs = \{ h(l,i),h(r,j) \}$. In this case, $\alpha' = t_1 + t_2 \ne 0$, 
$\Lambda = \{ (t_1, h(l,i) - i), (t_2,h(r,j)) \}$.

Now let us refocus on the \SG algorithm. It computes a function $\Lambda'$ from $\Lambda$ 
(returned by \group) by mapping each fresh variable $t$ to $\push{}(\Lambda(t),M(t))$ 
which is $\Lambda(t)$ but with the actual arguments of the recursive call $M(t)$ replaced by 
the formal parameters of $P$.

The \SG algorithm tries to compute a disjunct $\psi$ of the form $\bigwedge_i a_i$ 
that implies $\alpha'$ such that each $a_i$ uses only a single $t_i$. 
For every atom $a$ in $\alpha'$ containing multiple $t_i$'s the algorithm computes 
a disjunct (of the required form) implying $a$ by invoking the routine \hypervol (discussed in detail below) on $a$ .
However, this works only when $a$ uses the primitive operators at the outermost level, 
if not, the algorithm gives up and returns $false$ as a strengthening predicate.
Once it has computed $\psi$ it replaces the fresh variables in $\psi$ by their image in $\Lambda'$.
It adds the resulting formula to a collection $splits$.

Finally, the algorithm arbitrarily chooses a minimal formula $\psi$ from $splits$ and returns it to 
the caller.
Consider the call to \hypervol in the \SG algorithm. It takes as input an arithmetic atom $a$, 
a set of fresh variables $temps$ that are free in $a$ and a mapping $\mu$.
The mapping $\mu$ is constructed in lines (9)--(13). Clearly, each $\Lambda'(t)$
is an atom defined over the parameters of $P$ as every $M(t)$ is a recursive call to $P$
(note the $recfuncs$ argument passed to \group function which becomes the range of $M$).
Hence, every $\Lambda'(t)$ can be concretely evaluated on the counter-examples in 
$CtrEx$ since every counter example is an assignment of values to the inputs of $P$.
The function $\mu$ maps each fresh variable $t$ to the results of evaluating the 
counter-examples on $\Lambda'(t)$.
It is necessary to ensure that whenever \SG computes a disjunct $\pi$ implying 
an atom $a$ in $\alpha'$, every atom in $\pi$ involving a variable $t$ satisfies $\mu(t)$.
This will ensure that constraint (d) (given above) holds.
We now discuss the routine \hypervol in greater detail.

\paragraph{FindHyperVolume.}

\begin{figure}
\begin{algorithm}[H]
\SetKwFunction{conle}{ConvertToLE}
\textbf{input: } An atom $\alpha$ of the form $c_1t_1 + \cdots + c_kt_k + a \; \relop \; 0$,
 where $t_1,\cdots,t_k \in temps$, $a \in Atom$ \\
\textbf{output: } A minimal formula of the form $\bigwedge_i a_i$ that implies $\alpha$ 
s.t. $a_i \in Atom$ and $\fv(a_i) \subseteq \{ t_i \}$, $1 \le i \le k$ \\
 
\hypervol{$\alpha,temps,\mu$} 
\Begin{
  \nl Let $\phi = \conle(\alpha)$ \;
  \nl \If{$\phi$ is $\alpha_1 \vee \alpha_2$}{
  	\nl \Return weakest of \hypervol{$\alpha_1,temps,\mu$}, \hypervol{$\alpha_2,temps,\mu$} \;
  }  
  \nl \If{$\phi$ is $\alpha_1 \wedge \alpha_2$}{
  	\nl \Return conjoin of \hypervol{$\alpha_1,temps,\mu$}, \hypervol{$\alpha_2,temps,\mu$} \;
  }  
  \nl Let $\{ t_1',\cdots t_k' \}$ be a set of fresh variables \;    
  \nl \For{$i$ ranging from 1 to $k$} {
     \tcp{by precondition $\coeff(t_i) \ne 0$}     
     \nl \If{$\coeff(t_i) > 0$} {
          \nl $J_i =  t_i \le t_i'$ \;
      }
      \nl \Else{
          \nl $J_i = t_i \ge t_i'$ \;         	             	            	    
      }
  }
  \nl Let $\varphi = (c_1t_1 + \cdots + c_kt_k + a = 0) 
   \wedge \bigwedge \limits_{i=1}^{k} \bigwedge \limits_{x_i \in \mu(t_i)} J_i[x_i/t_i]$ \;     
   \nl  \If{$\varphi$ is satisfiable} {
         \nl Let $Z$ be a model for $\varphi$ \;         
		 \nl \Return $\bigwedge \limits_{i=1}^{k} J_i[Z(t_i')/t_i']$ \;
    }
    \nl \Return $false$ \;
}

\conle{$\alpha$}
\Begin{
	Let $\alpha = c_1t_1 + \cdots + c_kt_k + a \; \relop \; 0$ \;
	Let $T$ denote $c_1t_1 + \cdots + c_kt_k + a$ \;
	Let $\epsilon$ be a small constant \;
	$\relop$ match \\
	\Begin{
		Case $<$: \conle{$T + \epsilon \le 0$} \;
		Case $>$: \conle{$T - \epsilon \ge 0$} \;
		Case $\le$: $\alpha$ \;
		Case $\ge$: $-(c_1t_1) - \cdots - (c_kt_k) - (a) \le 0$ \;
		Case $\ne$: \conle{$T < 0$} $\vee$ \conle{$T > 0$} \;
		Case $=$: \conle{$T \le 0$} $\wedge$ \conle{$T \ge 0$} \;
	}
	
}
\end{algorithm}
\caption{An efficient algorithm for computing the largest hypercube implying the input 
atomic predicate when it is linear} \label{fig:hypervol-algo}
\end{figure}

Figure~\ref{fig:hypervol-algo} shows the algorithm that computes the \hypervol.
By the precondition, the input $\alpha$ is of the form 
$c_1t_1 + \cdots + c_kt_k + a \; \relop \; 0$ which is a half-space in an euclidean 
space with atleast $k$ dimensions (one dimension for each $t_i$).
The output of \hypervol is a conjunction of $k$ unary predicates which defines 
a hyper-volume and hence the name \hypervol.

Due to our assumption that the strengthening predicate is linear, the unary predicates 
outputted by \hypervol are linear. Hence, the hyper-volume is actually a $k$ dimensional 
hyper-cube with edges parallel to axes corresponding to $t_i$'s.
The algorithm looks for a minimal (i.e, weakest) hyper-cube implying the input predicate $\alpha$.
Without loss of generality assume that $\relop$ is $\le$.
The function $\conle$ converts every $\alpha$ to this form that uses only $\le$ 
as shown in Figure~\ref{fig:hypervol-algo}.
However, in case $\relop$ is $=$ or $\ne$ we get a formula with two atoms after the conversion 
which are specially handled in lines (2)--(5).

The logic of the algorithm is as follows: 
Since $\alpha$ is a half-space, the weakest hyper-cube implying $\alpha$ will have one vertex on 
the hyper-plane $c_1t_1 + \cdots + c_kt_k + a = 0$ and all the $k$ edges incident on the 
vertex will be unbounded.
Any point $(t_1',\cdots,t_k')$ (ignoring the variables in $a$) on the hyper-plane
defines $2^{k}$ \emph{hyper-octants} (the generalization of quadrant to higher dimensions).
\eg{} $\bigwedge_i t_i \ge t_i'$ is a hyperoctant that contains only points whose $i^{th}$ coordinate 
has a value greater than or equal to $t_i'$.
Exactly one of the hyper-octants lie completely inside the half-space $\alpha$.
This hyper-octant can be directly determined from the coefficients of the variables $t_i$ in the 
hyper-plane equation.
Once the hyper-octant is fixed, the algorithm picks a point $(t_1',\cdots,t_k')$ such that
the hyper-octant induced by it (which is fixed in the earlier step) contains all the points 
$\{ (x_1,\cdots,x_k) \vbar \forall 0 \le i \le k, x_i \in \mu(t_i) \}$.

Note that the algorithm essentially finds a solution to a bunch of linear constraints using
a SMT solver which is not very expensive.

We now illustrate this procedure on the atomic predicate $\alpha: t_1 + t_2 + 1 \ne -1$ when
$temps = \{ t_1,t_2 \}$ and $\mu(t_1) = \mu(t_2) = \{ 0 \}$. 
The atomic predicate has the operator $\ne$.
Invoking the procedure \conle on $\alpha$ will result in 
$t_l + t_r + 1 \le -1.1 \vee t_l + t_r + 1 \ge -0.9$ assuming $\epsilon$ is $0.1$. 

First consider the invocation of \hypervol on $t_1 + t_2 + 1 \le -1.1$. Since, coefficients 
of $t_1$ and $t_2$ are positive the algorithm will fix the quadrant $t_1 \le t_1'$ and $t_2 \le t_2'$
for some $t_1'$ and $t_2'$ that satisfy the equation $t_1' + t_2' + 1 = -1.1$. 
This is the only quadrant that would be fully contained in the half-space $t_1 + t_2 + 1 \le -1.1$.
\hypervol will try to find a satisfying assignment for the formula 
$t_1' + t_2' + 1 = -1.1 \wedge 0 \le t_1' \wedge 0 \le t_2'$ but would fail as this is unsatisfiable.
Therefore this invocation of \hypervol would return $false$.

Now consider the the other invocation on $-t_1 - t_2 - 1 \le -0.9$. Running \hypervol on this 
comes down to finding a satisfiable assignment for $-t_1' - t_2' - 1 = -0.9 \wedge 0 \ge t_1' \wedge 0 \ge t_2'$.
This formula has exactly two models namely, $(-1,-0.9)$ and $(-0.9,-1)$ (nevertheless, both would will result in the 
same strengthening predicate). 
If \hypervol chooses $(-1,-0.9)$ we get the output as $t_1 \ge -1 \wedge t_2 \ge -0.9$.
 
\paragraph{\textbf{EquivForms}.}

\begin{figure}
\begin{align*}
& \inferrule{\pathc \imp B \\ a \instOf con(\gamma_1,\cdots,\gamma_n) \in \pathc \\ a = b \in \pathc}
{\pathc \wedge (a.\gamma_1 = b.\gamma_1) \wedge \cdots \wedge (a.\gamma_n = b.\gamma_n) \imp B} \\
%
& \inferrule{\pathc \imp B \\ a = b \in \pathc \\ a \in \fv(B)}{\pathc \imp  B[b/a]}
%
%& \inferrule{\pathc \imp B \\ b \le a \in \pathc \\ a \in \fv(B) \\ \text{ fresh } u}
%{\pathc \cup \{u = a-b, u \ge 0\} \models B[(b + u)/a]} \\
%%
%&\inferrule{b < a \in \pathc, a \in \fv(B), \text{ fresh } u, \pathc \models B}
%{\pathc \cup \{u = a-b, u > 0\} \models B[(b + u)/a]} 
\end{align*}
\caption{Definition of the procedure $EquiForms$ as a set of rewrite rules.} \label{fig:equivform-algo}
\end{figure}

Figure~\ref{fig:equivform-algo} shows an implementation the routine \equivforms as a set of rewrite rules. 
Given a formula of the form $\pathc \imp B$, it generates a bounded number of
equivalent forms of the formula by repeatedly applying the rewrite rules. It collects the consequences
that occur at each rewrite step where each consequence is an implication of the form $\pathc' \imp B'$. 
The R.H.S  of the set of generated consequences (the $B'$'s) are returned to the caller.
Consider the first rewrite rule that derives from the equality of two algebraic data types 
the equality of its constituents. In the presence of recursive data types this may result in 
an unbounded number of consequences. However, it suffices to consider only those consequences 
whose $FieldAtom$s length is bounded by the maximum length of the $FieldAtom$s in the 
input path condition $\pathc$. 
In the future we plan to extend \equivforms to consider inequality predicates as well.

