\section{The idea behind the algorithm.}

\begin{figure}
\begin{myprogram}
Tree := Emp() \\
\> \>   :=  N(x: Int, l: Tree, r: Tree) \\     
\\
s(t : Tree) : Int \{ \\
\pnl \> t match \{ \\
\pnl \> case Emp() => 0; \\
\pnl \> case N(x,l,r) => s(l) + s(r) + 1; \\
\> \} \\
\} ensuring(res => res != -1)
\end{myprogram}
\caption{A procedure that computes the size of a binary tree.} \label{fig:eg}
\end{figure}
%
We first explain the intuition behind the algorithm with the simple procedure 
shown in Figure~\ref{fig:eg} which will also serve as a running example.
The post-condition $res \ne - 1$ is valid but is not inductive. This is because
$s(l) \ne -1$  and $s(r) \ne -1$ does not imply $s(l) + s(r)  + 1 \ne -1$.
However, if there exists a strengthening predicate $\rho$ then 
$s(l) \ne -1 \wedge \rho[l/t]$  and $s(r) \ne -1 \wedge \rho[r/t]$ should 
imply $s(l) + s(r)  + 1 \ne -1$ (of course it should also imply $\rho$ to be inductive).
But there is also a syntactic restriction to $\rho[l/t]$, it has to be defined
purely over $l$ and it cannot refer to $r$. For instance, $\rho[l/t]$ cannot be 
$s(l) + s(r)  + 1 \ne -1$. 
This is because, the post-condition has to hold in general and there is no generic way
of getting a handle to $r$ while we are in the left sub-tree $l$. 
For the same reason, $\rho[r/t]$ also ought to be in terms of $r$.

Essentially the problem is to find two predicates $\psi_1$ and
$\psi_2$ where $\fv(\psi_1) \subseteq \{ l \}$, $\fv(\psi_2) \subseteq \{ r \}$ 
and $\psi_1 \wedge \psi_2 \imp s(l) + s(r) + 1$.
There can be infinitely many such predicates and the desired invariant is one of them.
Say there is a way to find weakest such  $\psi_1 \wedge \psi_2$. 
This implies that $\rho[l/t] \wedge \rho[r/t]$ should be stronger than $\psi_1 \wedge \psi_2$.
We consider $\psi: \push{S}(\psi_1) \wedge \push{S}(\psi_2)$ 
as a potential strengthening predicate and construct a new post-condition $res \ne -1 \wedge \psi$.
If this is not inductive we recursively apply the same procedure on this new post-condition.
It can shown that if the post-condition is valid then we can find a sufficiently strong 
inductive invariant by this approach (in the limit) provided $\psi_1 \wedge \psi_2$ satisfy 
the weakness property. 
If there exists no unique weakest formula then the claim holds for some weakest formula 
so we have to backtrack and try all possible weakest formulas at every step of the recursion, for completeness. 
To restrict the search for the weakest formula when there exists many, we use a set of counter-examples
and make sure that $\psi$ satisfies the counter-examples.
The algorithm is non-terminating for the reasons explained above. See the end of the document 
for some thoughts on completeness and termination.
 
