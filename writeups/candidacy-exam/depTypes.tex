\newcommand{\dt}[2]{\mathit{\{ #1 \vbar #2\}}}
\newcommand{\subtype}{\mathit{<:}}
\newcommand{\sem}[1]{\sembrack{#1}}

\subsection{Dependent and Refinement Types}

The papers that are discussed in the subsequent sections mainly deal with 
automatic verification of properties in the presence of higher-order language features such as closures and data structures.
The papers use \emph{dependent types} which is a mechanism for specifying and checking properties and contracts of higher-order programs. In this section we introduce and discuss dependent types, subsequently we discuss how the papers extend the dependent type system and also provide support automatic dependent type inference which is closely related to automatic invariant inference.

Dependent types extend the expressivity of ordinary types by augmenting them with a \emph{refinement} predicate. For example, $x:\dt{\nu: Int}{1 \le \nu \wedge \nu \le 99}$ denotes that $i$ is an integer between 1 and 99. The predicates can be defined over a variable $\nu$, which represents the value of the expression that is being typed, and other program variables that are live at that program point.
Dependent types are of two classes: (a) dependent base types that are of the form $\dt{\nu:B}{\phi}$ where, $B$ is a base type which are the usual types like Int, Bool, data types etc., and $\phi$ is a refinement predicate (a boolean valued expression)
(b) dependent function types that are of the form $\{ x:T_1 \mapsto T_2\}$ 
where $T_1,T_2$ are dependent types.
The papers discuss some extensions to the dependent types which are presented later.
 
Figure~\ref{fig:typerules} shows some of the interesting type checking rules 
for a language similar to simple lambda calculus (the rules shown are not complete, they are only illustrative, see \cite{rjhala:PLDI08} for the complete set of rules).
%
\begin{figure}
\begin{tabular}{ll}
\inferrule
	{\Gamma;\nu:B \vdash e:bool}	
	{\Gamma \vdash \dt{\nu:B}{e}} \textsc{[WF-Base]}
&
\inferrule
	{\Gamma;x:T_1 \vdash T_2}	
	{\Gamma \vdash x:T_1 \mapsto T_2} \textsc{[WF-Fun]} \\ 
& 	
\end{tabular} 
\begin{tabular}{l}
\inferrule
	{\Gamma \vdash e:T_1 \\ \Gamma \vdash T_1 \subtype T_2 \\ \Gamma \vdash T_2}
	{\Gamma \vdash e:T_2} \textsc{[Sub]} \\ \\
\inferrule
	{\Gamma;x:T_1 \vdash e:T_2 \\ \Gamma \vdash x:T_1 \mapsto T_2}	
	{\Gamma \vdash \lambda x.e : (x:T_1 \mapsto T_2)} \textsc{[Fun]} \\ \\
\inferrule
	{\Gamma \vdash e_1: (x:T_1 \mapsto e:T_2) \\ \Gamma \vdash e_2: T_1}	
	{\Gamma \vdash e_1 \; e_2 : T_2[e_2/x]} \textsc{[App]} \\ \\
\inferrule
	{\Gamma \vdash e_1: bool \\ \Gamma;e_1 \vdash e_2: T \\ \Gamma;\neg e_1 \vdash e_3: T \\ \Gamma \vdash T}	
	{\Gamma \vdash \text{if } e_1 \text{ then } e_2 \text{ else } e_3 : T} \textsc{[If]} 	 \\ \\
\inferrule
	{\Gamma \vdash e_1: T_1 \\ \Gamma;x:T_1 \vdash e_2: T_2 \\ \Gamma \vdash T_2}	
	{\Gamma \vdash \text{let } x = e_1 \text{ in } e_2 : T_2} \textsc{[Let]} 	 \\ \\
\inferrule
	{\Gamma \vdash T_1 \\ \Gamma;x:T_1 \vdash e_1: T_1 \\ \Gamma;x:T_1 \vdash e_2: T_2 \\ \Gamma \vdash T_2}	
	{\Gamma \vdash \text{let rec } x = e_1 \text{ in } e_2 : T_2} \textsc{[Let-Rec]} 	 \\ \\
\inferrule
	{\text{Valid}(\sem{\Gamma} \wedge \sem{e_1} \Rightarrow \sem{e2})}	
	{\Gamma \vdash \dt{\nu:B}{e_1} \subtype \dt{\nu:B}{e_2}} \textsc{[Dec-sub]}  
	\end{tabular}
\caption{Rules for dependent type checking} \label{fig:typerules}
\end{figure}
%
In the figure, $\Gamma$ is the type environment which is a sequence of
type bindings of the form $x:T$ (where $x$ is a variable) and predicates $e$. 
The rules \textsc{[WT-Base]} and \textsc{[WT-Fun]} define well formedness of dependent types. Informally, a base dependent is well formed iff the refinement predicate is a bool expression whose free variables are bound in the environment. A function refinement type is well formed iff its domain and range types are well formed dependent types. The rules \textsc{[Sub]}, \textsc{[Fun]}, \textsc{[Let]} and \textsc{[Let-Rec]} are straight-forward and similar to normal typing rules.
Note that in rule \textsc{[App]} the type of expression $e_1 \; e_2$ is $T_2$ but
with $x$ replaced by $e_2$ this is necessary as $x$ could be used in the refinement
predicate of $T_2$. In rule \textsc{[If]} the guard expression $e_1$ (or its negation) is included in the environment while type checking branches. This
allows the type system to be path-sensitive. 

The most interesting rule is \textsc{[Dec-Sub]} (abbreviation for decidable subtyping) which defines what it means for one dependent base type to be a subtype of another dependent base type. $\sem{\Gamma}$ is the formula corresponding to 