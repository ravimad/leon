\newcommand{\dt}[2]{\mathit{\{ #1 \vbar #2\}}}
\newcommand{\subtype}{\mathit{<:}}
\newcommand{\sem}[1]{\sembrack{#1}}

\subsection{Dependent Types}

The papers that are discussed in the subsequent sections mainly deal with 
automatic verification of properties in the presence of higher-order language features such as closures and data structures.
The papers use \emph{dependent types} which is a mechanism for specifying and checking properties and contracts of higher-order programs. In this section we introduce and discuss dependent types, subsequently we discuss how the papers extend the dependent type system and also provide support automatic dependent type inference which is closely related to automatic invariant inference.

Dependent types extend the expressivity of ordinary types by augmenting them with a \emph{refinement} predicate. For example, $x:\dt{\nu: Int}{1 \le \nu \wedge \nu \le 99}$ denotes that $i$ is an integer between 1 and 99. The predicates can be defined over a variable $\nu$, which represents the value of the expression that is being typed, and other program variables that in scope at that program point.
Dependent types are of two classes: (a) dependent base types that are of the form $\dt{\nu:B}{\phi}$ where, $B$ is a base type which are the usual types like Int, Bool, algebraic data types etc., and $\phi$ is a refinement predicate (a boolean valued expression)
(b) dependent function types that are of the form $\{ x:T_1 \mapsto T_2\}$ 
where $T_1,T_2$ are dependent types.
The papers extend dependent types defined here in various ways which are discussed later in the appropriate sections.
 
Figure~\ref{fig:typerules} shows some of the interesting type checking rules 
for a language similar to simple lambda calculus (the rules shown are not complete, they are only illustrative, see \cite{rjhala:PLDI08} for the complete set of rules).
%
\begin{figure}
\begin{tabular}{ll}
\inferrule
	{\Gamma;\nu:B \vdash e:bool}	
	{\Gamma \vdash \dt{\nu:B}{e}} \textsc{[WF-Base]}
&
\inferrule
	{\Gamma;x:T_1 \vdash T_2}	
	{\Gamma \vdash x:T_1 \mapsto T_2} \textsc{[WF-Fun]} \\ 
& 	
\end{tabular} 
\begin{tabular}{l}
\inferrule
	{\Gamma \vdash e:T_1 \\ \Gamma \vdash T_1 \subtype T_2 \\ \Gamma \vdash T_2}
	{\Gamma \vdash e:T_2} \textsc{[Sub]} \\ \\
\inferrule
	{\Gamma;x:T_1 \vdash e:T_2 \\ \Gamma \vdash x:T_1 \mapsto T_2}	
	{\Gamma \vdash \lambda x.e : (x:T_1 \mapsto T_2)} \textsc{[Fun]} \\ \\
\inferrule
	{\Gamma \vdash e_1: (x:T_1 \mapsto e:T_2) \\ \Gamma \vdash e_2: T_1}	
	{\Gamma \vdash e_1 \; e_2 : T_2[e_2/x]} \textsc{[App]} \\ \\
\inferrule
	{\Gamma \vdash e_1: bool \\ \Gamma;e_1 \vdash e_2: T \\ \Gamma;\neg e_1 \vdash e_3: T \\ \Gamma \vdash T}	
	{\Gamma \vdash \text{if } e_1 \text{ then } e_2 \text{ else } e_3 : T} \textsc{[If]} 	 \\ \\
\inferrule
	{\Gamma \vdash e_1: T_1 \\ \Gamma;x:T_1 \vdash e_2: T_2 \\ \Gamma \vdash T_2}	
	{\Gamma \vdash \text{let } x = e_1 \text{ in } e_2 : T_2} \textsc{[Let]} 	 \\ \\
\inferrule
	{\Gamma \vdash T_1 \\ \Gamma;x:T_1 \vdash e_1: T_1 \\ \Gamma;x:T_1 \vdash e_2: T_2 \\ \Gamma \vdash T_2}	
	{\Gamma \vdash \text{let rec } x = e_1 \text{ in } e_2 : T_2} \textsc{[Let-Rec]} 	 \\ \\
\inferrule
	{\text{Valid}((\sem{\Gamma} \wedge e_1) \Rightarrow e_2)}	
	{\Gamma \vdash \dt{\nu:B}{e_1} \subtype \dt{\nu:B}{e_2}} \textsc{[Dec-sub]}  
	\end{tabular}
\caption{Rules for dependent type checking} \label{fig:typerules}
\end{figure}
%
In the figure, $\Gamma$ is the type environment which is a sequence of
predicates $e$ and type bindings of the form $x:T$ (where $x$ is a variable). 
The rules \textsc{[WT-Base]} and \textsc{[WT-Fun]} define well formedness of dependent types. Informally, a base dependent is well formed iff the refinement predicate is a boolean expression whose free variables are bound in the environment. A function refinement type is well formed iff its domain and range types are well formed dependent types. The rules \textsc{[Sub]}, \textsc{[Fun]}, \textsc{[Let]} and \textsc{[Let-Rec]} are straight-forward and similar to normal typing rules.
Note that in rule \textsc{[App]} the type of expression $e_1 \; e_2$ is the result 
of replacing $e_2$ by $x$ in $T_2$. This is necessary as $x$ could be used in the refinement predicate of $T_2$. In rule \textsc{[If]} the guard expression $e_1$ (or its negation) is included in the environment while type checking branches. This
allows the type system to be path-sensitive. 

The most interesting rule is \textsc{[Dec-Sub]} (abbreviation for decidable subtyping) which defines the subtype relationship between the dependent base types. $\sem{\Gamma}$ is a logical formula representing the environment $\Gamma$ and is defined as follows:
$\sem{\Gamma} \equiv \bigwedge \{ e \vbar e \in \Gamma \} \wedge \bigwedge \{ e[x/\nu] \vbar x:\dt{\nu:B}{e} \in \Gamma \}$. 
A dependent base type $\dt{\nu:B}{e_1}$ is a subtype of $\dt{\nu:B}{e_2}$ iff 
$e_1$ implies $e_2$ in the context $\Gamma$. 
It is assumed that there exists a decision procedure that can prove the implication.
The subtype relationship between the dependent function types is defined in the standard way using contravariance of range types.
%: $(T_1 \mapsto T_2) \subtype (\T_1' \maps T_2')$ iff $\T_2' \subtype \T_1'$ 
%(note that the covariance of domain types is implicitly captured by rule \textsc{[Sub]}).
The above rules can be extended to polymorphic base types in a straight-forward way.

We now illustrate how dependent types can be used to verify specifications using 
the list reversal example shown in Figure~\ref{fig:eg}.
Figure~\ref{fig:deptypes-eg} shows the same list reversal program 
in a slightly different syntax which is borrowed from \cite{rjhala:ESOP13}.
%
\begin{figure}
\begin{myprogram}
\\
\pnl Data L \\
\pnl \>   Nil :: $\dt{\nu:\text{L}}{s(\nu) = 0}$  \\
\pnl \>   Cons :: x:Int $\mapsto$ l:L $\mapsto$ 
				$\dt{\nu:\text{L}}{\text{s(l) + 1}}$ \\
\\
\pnl s :: L $\mapsto$ Int \\
\pnl \>    s(Nil()) = 0 \\
\pnl \>    s(Cons(h, t)) = 1 + s(t) \\
\\
\pnl rev :: l:L $\mapsto$ $\dt{\nu:\text{L}}{\text{s}(\nu) = \text{s(l)}}$ \\
\pnl \> rev0(l, Nil())  \\
\\    
\pnl rev0 :: l1:L $\mapsto$ l2:L $\mapsto$  \\
\> \> \> \> \> $\dt{\nu:\text{L}}{\text{s}(\nu) = \text{s(l1) + s(l2)}}$  \\
\pnl \> rev0(Nil()) = l2 \\
\pnl \> rev0(Cons(x, xs)) = rev0(xs, Cons(x, l2))
\end{myprogram}
\caption{A simple list reveral procedure in Scala} \label{fig:deptypes-eg}
\end{figure}
%
As shown in the figure, the function contracts (pre and postconditions) are expressed as refinement predicates of parameters and return types respectively. 
The safety property that the sizes of the input and the reversed list of $rev$ are equal is expressed as a refinement predicate of the return type of $rev$. If the 
program type checks then the safety property is bound to hold.
Type checking essentially reduces to proving a set of implications on the refinement predicates. In this example, the implication that needs to be proven to type check the recursive case of $rev0$ is $l1 = Cons(x,xs) \wedge s(\nu) = s(xs) + s(Cons(x,l2)) \Rightarrow s(\nu) = s(l1) + s(l2)$.
Proving this requires reasoning about algebraic data structures and recursive functions. If the decision procedures are powerful enough to handle these features then the program will type check.

Dependent types is only a mechanism for specifying contracts and safety properties of higher-order program. They as such do not address the problem of automatically inferring inductive invariants (or equivalently inductive refinement predicates). Dependent type checking succeeds only when the refinement predicates of types of recursive procedures are inductive invariants. The papers discussed in the next sections target automatic inference of refinement predicates.