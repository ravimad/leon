\newcommand{\dt}[2]{\mathit{\{ #1 \vbar #2\}}}
\newcommand{\subtype}{\mathit{<:}}
\newcommand{\sem}[1]{\sembrack{#1}}

\subsection{Dependent and Refinement Types}

The papers that are discussed in the subsequent sections mainly deal with 
automatic verification of properties in the presence of higher-order language features such as closures and data structures.
The papers use \emph{dependent types} which is a mechanism for specifying and checking properties and contracts of higher-order programs. In this section we introduce and discuss dependent types, subsequently we discuss how the papers extend the dependent type system and also provide support automatic dependent type inference which is closely related to automatic invariant inference.

Dependent types extend the expressivity of ordinary types by augmenting them with a \emph{refinement} predicate. For example, $x:\dt{\nu: Int}{1 \le \nu \wedge \nu \le 99}$ denotes that $i$ is an integer between 1 and 99. The predicates can be defined over a variable $\nu$, which represents the value of the expression that is being typed, and other program variables that are live at that program point.
Dependent types are of two classes: (a) dependent base types that are of the form $\dt{\nu:B}{\phi}$ where, $B$ is a base type which are the usual types like Int, Bool, data types etc., and $\phi$ is a refinement predicate (a boolean valued expression)
(b) dependent function types that are of the form $\{ x:T_1 \mapsto T_2\}$ 
where $T_1,T_2$ are dependent types.
The papers discuss some extensions to the dependent types which are presented later.
 
Figure~\ref{fig:typerules} shows some of the interesting type checking rules 
for a language similar to simple lambda calculus (the rules shown are not complete, they are only illustrative, see \cite{rjhala:PLDI08} for the complete set of rules).
%
\begin{figure}
\begin{tabular}{ll}
\inferrule
	{\Gamma;\nu:B \vdash e:bool}	
	{\Gamma \vdash \dt{\nu:B}{e}} \textsc{[WT-Base]}
&
\inferrule
	{\Gamma;x:T_1 \vdash T_2}	
	{\Gamma \vdash x:T_1 \mapsto T_2} \textsc{[WT-Fun]} \\ 
& 	
\end{tabular} 
\begin{tabular}{l}
\inferrule
	{\Gamma \vdash e:T_1 \\ \Gamma \vdash T_1 \subtype T_2 \\ \Gamma \vdash T_2}
	{\Gamma \vdash e:T_2} \textsc{[Sub]} \\ \\
\inferrule
	{\Gamma;x:T_1 \vdash e:T_2 \\ \Gamma \vdash x:T_1 \mapsto T_2}	
	{\Gamma \vdash \lambda x.e : (x:T_1 \mapsto T_2)} \textsc{[Fun]} \\ \\
\inferrule
	{\Gamma \vdash e_1: (x:T_1 \mapsto e:T_2) \\ \Gamma \vdash e_2: T_1}	
	{\Gamma \vdash e_1 \; e_2 : T_2[e_2/x]} \textsc{[App]} \\ \\
\inferrule
	{\Gamma \vdash e_1: bool \\ \Gamma;e_1 \vdash e_2: T \\ \Gamma;\neg e_1 \vdash e_3: T \\ \Gamma \vdash T}	
	{\Gamma \vdash \text{if } e_1 \text{ then } e_2 \text{ else } e_3 : T} \textsc{[If]} 	 \\ \\
\inferrule
	{\Gamma \vdash e_1: T_1 \\ \Gamma;x:T_1 \vdash e_2: T_2 \\ \Gamma \vdash T_2}	
	{\Gamma \vdash \text{let } x = e_1 \text{ in } e_2 : T_2} \textsc{[Let]} 	 \\ \\
\inferrule
	{\Gamma \vdash x: T_1 \\ \Gamma;x:T_1 \vdash e_1: T_1 \\ \Gamma;x:T_1 \vdash e_2: T_2 \\ \Gamma \vdash T_2}	
	{\Gamma \vdash \text{let rec } x = e_1 \text{ in } e_2 : T_2} \textsc{[Let-Rec]} 	 \\ \\
\inferrule
	{\text{Valid}(\sem{\Gamma} \wedge \sem{e_1} \Rightarrow \sem{e2})}	
	{\Gamma \vdash \dt{\nu:B}{e_1} \subtype \dt{\nu:B}{e_2}} \textsc{[Dec-sub]}  
	\end{tabular}
\caption{Rules for dependent type checking} \label{fig:typerules}
\end{figure}
%
