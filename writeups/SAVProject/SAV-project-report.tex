\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}

\begin{document}
\title{SAV Project Report \\ Templates in Function Postconditions}
\author{Ravichandhran Kandhadai Madhavan \\ ravi.kandhadai@epfl.ch}
\maketitle

\newcommand{\dash}[1]{\overline{#1}}
\newcommand{\progst}[1]{\texttt{#1}}
\newcommand{\temp}{\mathit{\phi_{temp}}}
\newcommand{\post}{\mathit{\phi_{post}}}
\newcommand{\body}{\mathit{\phi_{body}}}
\newcommand{\zerovec}{\mathbf{0}}
\newcommand{\Body}[1]{\mathit{Body(#1)}}
\newcommand{\Post}[1]{\mathit{Post(#1)}}
\newcommand{\Temp}[1]{\mathit{Temp(#1)}}
%\newcommand{\implies}{\Rightarrow}

\input{genericmacros}

\section{Problem Definition}

In this project we enhance the flexibility of the Leon verification engine by allowing the users to specify abstract postconditions that consists of the property to be verified and also a linear template which is a boolean valued expression containing linear inequalities with unknown coefficients.
The unknown coefficients would be automatically bound to appropriate values so that the verification of the property succeeds.
The domain of the unknown coefficients in the templates is fixed as the set of real numbers.

In the current implementation, the abstract postconditions are specified using the following syntax: \progst{ensuring(res => $\phi$(res,$\cdots$)  template((a, b, c, $\cdots$) => $\temp$(a,b,c,res,$\cdots$)} where, $\phi$ is a property defined over \progst{res} and arguments of the function, and $\temp$ is a template defined over \progst{res}, arguments and unknown coefficients (also referred to as template variables) \progst{a,b,c,$\cdots$}.

For example, \progst{ensuring(res => res != -1 template((a, b, c) => (a*res + b*x + c <= 0 \&\& b < 0)))} is an abstract postcondition. Here, the property to be verified is \progst{res != -1} and the template is \progst{(a*res + b*x + c <= 0 \&\& b < 0)} where $a$, $b$ and $c$ are the unknown coefficients.

Figure~\ref{fig:eg} shows an example that uses the above abstract postcondition.
%
\begin{figure}
\begin{myprogram}
\pnl \> def s(x: Int) : Int = \{ \\
\pnl \> \> if(x < 0) \\
\pnl \> \> \> - x \\
\pnl \> \> else  \\
\pnl \> \> \> 	s(x-1) + x\\
\pnl \> \} ensuring(res => res != -1  \\
\pnl \> \> \> template((a,b,c) => (a*res + b*x + c <= 0 \&\& b<0)))
\end{myprogram}
\caption{A simple program with an abstract postcondition containing templates} \label{fig:eg}
\end{figure}
%
For this example, our implementation binds the unknown coefficients $a$,$b$ and $c$ to 
the values $-6$, $-2$ and $1$, respectively.

We focus only on numerical Leon programs that do not use any data structures. We also require that every arithmetic expression in the program (including pre and postconditions) to be a \emph{linear combination} of program variables and function invocations.

\section{The Approach}

%We now discuss our approach for handling the abstract postconditions discussed above.

\subsection{Verification condition generation for abstract postconditions}

Let $X$ be a row vector of program variables and $A$ be a row vector of  template variables (unknown coefficients of the template).
An abstract postcondition with a property $\phi(X)$ and a template $\temp(X,A)$ should be interpreted as representing the postcondition $\post(X,A): \; \phi(X) \wedge \temp(X,A)$.
Using this interpretation of the abstract postconditions we generate a verification condition 
for the program in the standard way. 
The verification condition would be of the form $\body(X,A) \Rightarrow \post(X,A)$. Notice that $\body$ may also use the template variables as the verification condition is generated by assuming the postconditions for the recursive calls in the body.
For the postcondition to hold we need the verification condition to be valid. Since the template variables can be bound to any real value the goal is to find an $A$ such that the verification condition is valid. Formally, we need to prove
%
\begin{align}
& \exists A. \forall X. \; \body(X,A) \Rightarrow \post(X,A) \\
& \equiv  \exists A. \forall X. \; \body(X,A) \wedge \neg(\post(X,A)) \Rightarrow \mathit{false}
\label{eq:tempvc}
\end{align}

In general, $\body$ and $\post$ can be arbitrary boolean valued expressions belonging to our language. Therefore, they can contain user-defined functions.
However, we first focus on a restrictive case where the predicates do not contain any user-defined functions and gradually extend the approach to handle all expressions belonging our language.

\subsection{Solving a restricted case using Farkas' and Motzkin's Lemmas}

Let $A = (a_1 \cdots a_m)$ and $X = (x_1 \cdots x_n)$.
Let $\body \wedge \neg \post$ be of the form 
$\bigwedge \limits_{k=1}^{p} \sigma_k(X,A)$ with each $\sigma_k$ of the form 
$D_k (x_1 \cdots x_n \; 1)^T \le \zerovec$ where $D_k$ is a row vector of $(n+1)$ elements
which are constants or template variables.
Define $D_0$ as $(0 \cdots 0 \; 1)$.

Consider the constraint \ref{eq:tempvc} shown above. Say the above assumption about $\body \wedge \neg \post$ hold. 
Let $D$ be the $(n+1) \times (p+1)$ matrix $(D_0 \; D_1 \cdots D_k)^T$.
By Farkas' Lemma, a solution to constraint \ref{eq:tempvc} exists if
%
\begin{align}
\exists A. \exists \Lambda \in \mathbb{R}^{p+1}. \; \Lambda \ge \zerovec \wedge \Lambda D =(0 \cdots 0 \; 1) \label{eq:flemma}
\end{align}
%
Since $D$ has only the template variables and constants, constraint~\ref{eq:flemma} is a non-linear constraint involving the template variables and lambdas. If there exists a model for constraint~\ref{eq:flemma} then the values of the template variables in the model are a valid solution for the constraint~\ref{eq:tempvc}.

\paragraph{Extensions for handling mixed strict and non-strict inequalities.}

In the above case we required that each $\sigma_k$ is of the form 
$D_k (x_1 \cdots x_n \; 1)^T \le 0$. However, it is possible to extend the approach to
also support strict inequalities using \emph{Motzkin's transposition theorem}.

Let $\body \wedge \neg \post$ be of the form 
$\bigwedge \limits_{k=1}^{p} \sigma_k(X,A) \wedge \bigwedge \limits_{k=p}^{p+q} \delta_k(X,A)$,
where $\sigma_k$'s are defined as before and $\delta_k$'s are of the form 
$D_k (x_1 \cdots x_n \; 1)^T < \zerovec$.
By Motzkin's transposition theorem, a solution to constraint \ref{eq:tempvc} exists if
%
\begin{align}
& \nonumber
\exists A. \exists \Lambda_1 \in \mathbb{R}^{p+1}, \Lambda_2 \in \mathbb{R}^{q}, \Lambda = (\Lambda_1 \; \Lambda_2). \; \\ 
& \qquad \Lambda \ge \zerovec \wedge (\Lambda D =(0 \cdots 0 \; 1) \vee (\Lambda_2 > \zerovec \wedge \Lambda D = \zerovec)) \label{eq:motlemma}
\end{align}
%
Notice that we have disjunctions in the constraints when there are mixed strict and non-strict inequalities in the constraint~\ref{eq:tempvc}. 
%From an efficiency perspective reducing the number of strict inequalities could be beneficial.

\subsection{Extensions for handling disjunctions in the verification condition}

Handling disjunctions in constraint~\ref{eq:tempvc} is straight forward. We first
convert $\body \wedge \neg \post$ in to a DNF formula $\bigvee_i d_i$.
Constraint~\ref{eq:tempvc} is equivalent to 
%
\begin{align}
\exists A. \forall X. (\bigvee_i d_i) \Rightarrow false \\
\equiv \exists A. \bigwedge_i (\forall X. \; d_i \Rightarrow false)
\end{align}
%
Let $L_i =  (\forall X. \; d_i \Rightarrow false)$. We use the above approach to generate non linear constraints $C_i$ for each $L_i$ and solve the conjunction $C: \bigwedge C_i$.
If there exists a model for $C$ then the values of $A$ in the model will satisfy the 
constraint~\ref{eq:tempvc}.

\subsection{Extending the approach to handle User Defined Functions (UDFs) in the function body}

The Leon verification framework proposes an approach for generating verification conditions in the presence of calls to UDFs in the function body (like in Figure~\ref{fig:eg} which has a recursive call in the body). In the Leon approach, the calls to the UDFs are treated as logical functions and retained in the verification condition. For example, $\body$ for the program shown in Figure~\ref{fig:eg} will  be of the form 
$(x < 0 \wedge res = -x) \vee (x \ge 0 \wedge res = s(x-1) + x \wedge a*s(x-1) + b*x + c \le 0 \wedge b < 0 \wedge s(x-1) \ne -1)$.

We handle such a verification condition containing UDFs iteratively. Each iteration consists of two phases. In the first phase, we treat the UDFs as uninterpreted functions (UIFs) and solve for the template variables.
If there exists a solution then we halt and return the solution (the correctness of the solution is immediately evident).
If a solution does not exist, we proceed to the \emph{unrolling} phase which refines the verification condition using the definition of the called function and repeats the entire approach with the refined verification condition. We now explain the phases in detail.

\paragraph{Solving constraint~\ref{eq:tempvc} in the presence of uninterpreted functions.}

Say $\body$ and $\post$ in constraint~\ref{eq:tempvc} contain uninterpreted functions.
Let $\psi(X,A): \body(X,A) \wedge \neg \post(X,A)$.
Without loss of generality assume that $\psi$ is a conjunction of atomic predicates.
%As discussed in the earlier section, disjunctions are handled by splitting the problem in to several sub-problems that are disjunction free.

We first flatten the functions in $\psi$. 
We convert $\psi$, by introducing fresh variables say $X'$, to an equivalent formula $\psi_{I}(X,X',A) \wedge \psi_{F}(X,X',A)$ in which
$\psi_I$ is a formula without UIFs and 
$\psi_{F}$ is of the form $\bigwedge_i (v_i = f_i(Y_i))$ where, $f_i$ is a function symbol,  
$v_i \in X \cup X'$ is either a program variable or a newly introduced fresh variable 
and $Y_i \in (X \cup X')^n$ is a vector of program variables and fresh variables.  
Clearly, constraint~\ref{eq:tempvc} is equivalent to 
%
\begin{align}
\exists A. \forall X,X'. \; \psi_{I}(X,X',A) \wedge \psi_{F}(X,X',A) \Rightarrow false \label{eq:c2}
\end{align}

In the above constraint the UIFs in $\psi_{F}$ can be eliminated using the axiom of uninterpreted functions which states that the result of  two functions are equal if the functions have the same name and the arguments are equal. In the following we treat $\psi_F$ as a set of atomic predicates.
Let,
%
\begin{align}
\psi_R = \bigwedge \left\lbrace (\bigwedge \limits_{j=1}^{n} y_j = z_j) \Rightarrow v = u \vbar \exists f. \; v = f(y_1,\cdots,y_n), u = f(z_1,\cdots,z_n) \in \psi_F \right\rbrace  
\end{align}

Note that $\psi_R$ as defined above does not have any UIFs. By the axiom of uninterpreted functions constraint~\ref{eq:c2} is equivalent to 
%
\begin{align}
\exists A. \forall X,X'. \; \psi_{I}(X,X',A) \wedge \psi_{R}(X,X',A)  \Rightarrow false \label{eq:c3}
\end{align}
%
Constraint~\ref{eq:c3} can be solved using the approach discussed earlier. A model for constraint~\ref{eq:c3} is a valid model for constraint~\ref{eq:tempvc}.

\paragraph{Handling user-defined functions in the verification condition.}

Say the constraint~\ref{eq:tempvc} cannot be solved by treating the UDFs as uninterpreted functions. 
Let $\psi: \body \wedge \neg \post$. Without loss of generality assume that the function invocations in $\psi$ are flattened.
Let $Calls =\{ v_i = f_i(Y_i) \vbar 1 \le i \le n \}$ be the set of calls in $\psi$ and
$F = \{ f_i \vbar 1 \le i \le m \}$ be the set of user-defined function symbols in $\psi$. 
For each function in $f_i \in F$ let $\body_i$, $\post_i$ and $\temp_i$ denote the formulas corresponding to the body, postcondition and the template of the function $f_i$ and let $a_i$ denote the argument vector of the function.
If $f_i$ is recursive then $\body_i$ will use the template and postcondition of the recursive calls.

The approach fundamentally differs in the way recursive and non-recursive functions are handled (recursive functions also include mutually recursive functions).
Let $F_{rec} \subseteq F$ denote the set of recursive functions.
Let $\psi'$ be a formula defined as follows: 
%
\begin{align*}
\psi': & \quad \psi \wedge  \bigwedge \{ (\body_i \wedge \post_i)[res \mapsto v_i, a_i(1) \mapsto y_1,\cdots, a_i(n) \mapsto y_n] \\
	   & \qquad \qquad  \vbar v_i = f_i(y_1,\cdots,y_n) \in Calls, f_i \notin F_{rec} \}
\end{align*}

In simple words, $\psi'$ is the formula got by inlining the definition (and postcondition) of the non-recursive functions in $\psi$.
Define a formula $\psi_k$ for each recursive function $f_k \in F_{rec}$ as follows:
%
\begin{align*}
\psi_k: \quad \body_k \wedge \neg \temp_k
\end{align*}
%
%In simple words, $\phi_k$ is the condition that characterises that the template is inductive.
Define $\psi''$ as:
%
\begin{align*}
\psi'': & \quad \psi' \wedge  \bigwedge \{ \temp_k[res \mapsto v_k, a_k(1) \mapsto y_1,\cdots, a_k(n) \mapsto y_n] \\
	   & \qquad \qquad  \vbar v_k = f_k(y_1,\cdots,y_n) \in Calls, f_k \in F_{rec} \}
\end{align*}
%
That is, $\psi''$ further refines $\psi'$ by conjoining the templates of recursive calls in $\psi$.
We create a refined verification condition using $\psi''$ and $\psi_k$'s as follows:
%
\begin{align}
\exists A. \forall X. \; (\psi''(X,A) \Rightarrow false) \wedge \bigwedge_{f_k \in F_{rec}} (\psi_k(X,A) \Rightarrow false)
\end{align}

We repeat the above approach on the refined verification condition. That is, we treat the user defined functions in the refined verification condition as uninterpreted functions and try to solve for $A$. If unsuccessful we further refine the verification condition as described above. Notice that the process would terminate eventually as each recursive function is unrolled only once. 
However, the approach is incomplete. 

\section{Implementation Details and Experimental Evaluation}

This is an ongoing research work. As of now we have evaluated the approach on six micro-benchmarks. In each micro-benchmark the implementation successfully found an instantiation of the template to prove the desired property. In cases where the user haven't provided a template the implementation assumes a default template. In the future, we plan to evaluate the tool on many more benchmarks.

To test run the tool first compile the sources as detailed in the Leon documentation. To run a program \progst{test.scala} use the following command: \progst{leon --inferInv test.scala}.
The directory \progst{leon/testcases/ravi-testcases/numerical/} has some sample programs with templates. As mentioned before, it is assumed that all template variables are reals.

\section{Future Work}

In the current state, the templates cannot have user-defined functions. They must be defined only over the program variables. We plan to address this in the near future.

We found that for some programs it necessary to inline the definition of the called recursive functions in addition to its template while refining the caller verification condition. Currently, the approach does not perform such inlining (see the section on handling user-defined functions). The downside of incorporating this feature is that the approach may become non-terminating. In the future we plan to carefully incorporate such inlining of recursive functions.

The whole approach works only for a restricted subset of Leon programs that are linear as mentioned in the introduction. We plan to extended the approach to handle more complex programs with non-linear arithmetic operations and data structures.

\bibliographystyle{acm}
\bibliography{SAVproject}

\end{document}