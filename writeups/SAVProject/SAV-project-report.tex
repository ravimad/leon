\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}

\begin{document}
\title{SAV Project Report \\ Templates in Function Postconditions}
\author{Ravichandhran Kandhadai Madhavan \\ ravi.kandhadai@epfl.ch}
\maketitle

\newcommand{\dash}[1]{\overline{#1}}
\newcommand{\progst}[1]{\texttt{#1}}
\newcommand{\temp}{\mathit{\phi_{temp}}}
\newcommand{\post}{\mathit{\phi_{post}}}
\newcommand{\body}{\mathit{\phi_{body}}}
%\newcommand{\implies}{\Rightarrow}

\input{genericmacros}

\section{Problem Definition}

In this project we enhance the flexibility of the Leon verification engine by allowing the users to specify abstract postconditions that state the property to be verified and also a linear template which is a boolean valued expression containing linear inequalities with unknown coefficients.
The unknown coefficients would be automatically bound to appropriate values so that the verification succeeds.
The domain of the unknown coefficients in the templates is fixed as the set of real numbers.

In the current implementation, the abstract postconditions are specified using the following syntax: \progst{ensuring(res => res != -1 template((a, b, c) => (a*res + b*x + c <= 0 \&\& b < 0)))}. Here, the property to be verified is \progst{res != -1} and the template is \progst{(a*res + b*x + c <= 0 \&\& b < 0)} where $a$, $b$ and $c$ are the unknown coefficients.

Figure 2, shows an example that uses the above abstract postcondition.
%
\begin{figure}
\begin{myprogram}
\pnl \> def s(x: Int) : Int = \{ \\
\pnl \> \> if(x < 0) \\
\pnl \> \> \> - x \\
\pnl \> \> else  \\
\pnl \> \> \> 	s(x-1) + x\\
\pnl \> \} ensuring(res => res != -1  \\
\pnl \> \> \> template((a,b,c) => (a*res + b*x + c <= 0 \&\& b<0)))
\end{myprogram}
\caption{A simple program with an abstract postcondition containing templates}
\end{figure}
%
For this example, our implementation binds the unknown coefficients $a$,$b$ and $c$ to 
the values $-6$, $-2$ and $1$, respectively.

We focus only on numerical Leon programs that do not use any data structures. We also require that every arithmetic expression in the program (including pre and postconditions) to be a \emph{linear combination} of program variables and function invocations.

\section{The Approach}

We now discuss our approach for handling the abstract postconditions discussed above.
The approach has several sub-stages each of which is discussed below.

\subsection{Verification condition generation for abstract postconditions}

An abstract postcondition with a property $\phi(X)$ and a template $\temp(X,A)$,
where $X$ is a row vector of program variables and $A$ is row a vector of unknown coefficients (also called as template variables),
represents the postcondition $\post(X,A): \phi(X) \wedge \temp(X,A)$.
Using this interpretation of the abstract postconditions we generate a verification condition 
for the program in the standard way. 
The verification condition would be of the form $\body(X,A) \Rightarrow \post(X,A)$. Notice that $\body$ may also use the template variables as the verification condition is generated by assuming the postcondition for the recursive calls in the body.
For the postcondition to hold we need the verification condition to be valid. Since the $A$'s can be bound any real value the goal is to find an $A$ such that the verification condition is valid. Formally, we need to solve
%
\begin{align}
\exists A. \forall X. \body(X,A) \Rightarrow \post(X,A)
\label{eq:tempvc}
\end{align}

In general, $\body$ and $\post$ can be arbitrary boolean expressions over program and template variables belonging to our language. However, we first focus on a very restrictive case and gradually extend the approach to handle all expressions.

\subsection{Solving a restricted case using Farkas' and Motzkin's Lemmas}

Let $A = (a_1 \cdots a_m)$ and $X = (x_1 \cdots x_n)$.
Let $\body$ be of the form $\bigwedge \limits_{k=1}^{p} \sigma_k(X,A)$ and  
$\post$ be of the form $\sigma_0(X,A)$, where each $\sigma_k$ is of the form 
$(d_1 \cdots d_{n+1}) (x_1 \cdots x_n \; 1)^T \le 0$ where each $d_i$ is a 
constant or a template variable.





\section{The Approach}

\cite{ssriram:CAV03,ssriram:SAS04} proposes an approach based on constraint solving for inferring  inductive invariants that are instantiations of a predefined linear template. This approach can be adapted to construct the inference engine required by the project. Consider a function (belonging to the above restricted language) whose postcondition uses templates. Assume that the postcondition is a single atomic predicate. The verification condition computed by Leon for the function would be of the form: $\varphi: \bigwedge_i \varphi_i$, where,
$\mathit{\varphi_i: } \forall \dash{x}. \phi[\dash{x},\dash{a}] \Rightarrow p[\dash{x},\dash{a}]$, $\dash{x}$ is a set of program variables, $\dash{a}$ is a set of template variables, $\phi$ is a conjunction of linear atomic predicates defined over the program and template variables and $p$ is a single atomic predicate.
The goal is to find an assignment to $\dash{a}$ such that $\varphi$ holds.
As described in \cite{ssriram:CAV03}, by \textit{Farka's Lemma}, the values of $\dash{a}$ that satisfy $\varphi$ can be obtained by solving a system of non-linear real valued inequalities generated from $\varphi$. To solve the inequalities, the plan is to use the Z3 SMT solver integrated into Leon.

Allowing conjunctions in the postcondition is straight-forward as the generated  verification condition can be translated to the  form given by $\varphi$. However, supporting disjunctions in the postcondition is challenging as the verification condition generated by Leon cannot be directly reduced to the form given by $\varphi$. In such cases, the plan is to construct a formulae of the required form that is stronger than the verification condition. A solution for the stronger formulae is also a solution 
for the original verification condition.

In addition to implementing the above approach, I plan to extend it to handle templates with user-defined functions using the ideas presented in \cite{dirk:VMCAI07}. I also plan to combine this approach with the function unrolling mechanism of Leon to discover invariants that requires reasoning about multiple procedures.
 
\section{Completeness of the approach}

There are two sources of incompleteness: (a) Farka's Lemma is incomplete for integer arithmetic. There exists instantiations of templates that are inductive but cannot be found by the proposed approach. (b) Handling of disjunctions in the postconditions also introduces incompleteness.
As a part of the project I propose to study and characterize formulas (of the form given by $\varphi$) for which Farka's Lemma may be incomplete.

\section{Deliverables}

An enhanced Leon verifier that can support linear templates in postconditions. Ideally, it should be able to handle all linear transition systems when expressed as Leon programs.

\bibliographystyle{acm}
\bibliography{SAVproject}

\end{document}