\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}

\begin{document}
\title{SAV Project Report \\ Templates in Function Postconditions}
\author{Ravichandhran Kandhadai Madhavan \\ ravi.kandhadai@epfl.ch}
\maketitle

\newcommand{\dash}[1]{\overline{#1}}
\newcommand{\progst}[1]{\texttt{#1}}
\newcommand{\temp}{\mathit{\phi_{temp}}}
\newcommand{\post}{\mathit{\phi_{post}}}
\newcommand{\body}{\mathit{\phi_{body}}}
\newcommand{\zerovec}{\mathbf{0}}
%\newcommand{\implies}{\Rightarrow}

\input{genericmacros}

\section{Problem Definition}

In this project we enhance the flexibility of the Leon verification engine by allowing the users to specify abstract postconditions that state the property to be verified and also a linear template which is a boolean valued expression containing linear inequalities with unknown coefficients.
The unknown coefficients would be automatically bound to appropriate values so that the verification succeeds.
The domain of the unknown coefficients in the templates is fixed as the set of real numbers.

In the current implementation, the abstract postconditions are specified using the following syntax: \progst{ensuring(res => res != -1 template((a, b, c) => (a*res + b*x + c <= 0 \&\& b < 0)))}. Here, the property to be verified is \progst{res != -1} and the template is \progst{(a*res + b*x + c <= 0 \&\& b < 0)} where $a$, $b$ and $c$ are the unknown coefficients.

Figure 2, shows an example that uses the above abstract postcondition.
%
\begin{figure}
\begin{myprogram}
\pnl \> def s(x: Int) : Int = \{ \\
\pnl \> \> if(x < 0) \\
\pnl \> \> \> - x \\
\pnl \> \> else  \\
\pnl \> \> \> 	s(x-1) + x\\
\pnl \> \} ensuring(res => res != -1  \\
\pnl \> \> \> template((a,b,c) => (a*res + b*x + c <= 0 \&\& b<0)))
\end{myprogram}
\caption{A simple program with an abstract postcondition containing templates}
\end{figure}
%
For this example, our implementation binds the unknown coefficients $a$,$b$ and $c$ to 
the values $-6$, $-2$ and $1$, respectively.

We focus only on numerical Leon programs that do not use any data structures. We also require that every arithmetic expression in the program (including pre and postconditions) to be a \emph{linear combination} of program variables and function invocations.

\section{The Approach}

%We now discuss our approach for handling the abstract postconditions discussed above.

\subsection{Verification condition generation for abstract postconditions}

An abstract postcondition with a property $\phi(X)$ and a template $\temp(X,A)$,
where $X$ is a row vector of program variables and $A$ is row a vector of unknown coefficients (also referred to as template variables),
represents the postcondition $\post(X,A): \phi(X) \wedge \temp(X,A)$.
Using this interpretation of the abstract postconditions we generate a verification condition 
for the program in the standard way. 
The verification condition would be of the form $\body(X,A) \Rightarrow \post(X,A)$. Notice that $\body$ may also use the template variables as the verification condition is generated by assuming the postcondition for the recursive calls in the body.
For the postcondition to hold we need the verification condition to be valid. Since the $A$'s can be bound to any real value the goal is to find an $A$ such that the verification condition is valid. Formally, we need to prove
%
\begin{align}
& \exists A. \forall X. \body(X,A) \Rightarrow \post(X,A) \\
& \equiv  \exists A. \forall X. \body(X,A) \wedge \neg(\post(X,A)) \Rightarrow \mathit{false}
\label{eq:tempvc}
\end{align}

In general, $\body$ and $\post$ can be arbitrary boolean valued expressions belonging to our language. Therefore, they can contain user-defined functions.
However, we first focus on a restrictive case where the predicates do not contain any user-defined functions and gradually extend the approach to handle all expressions belonging our language.

\subsection{Solving a restricted case using Farkas' and Motzkin's Lemmas}

Let $A = (a_1 \cdots a_m)$ and $X = (x_1 \cdots x_n)$.
Let $\body \wedge \neg \post$ be of the form 
$\bigwedge \limits_{k=1}^{p} \sigma_k(X,A)$ with each $\sigma_k$ of the form 
$D_k (x_1 \cdots x_n \; 1)^T \le \zerovec$ where $D_k$ is a row vector of $(n+1)$ elements
which are constants or template variables.
Define $D_0$ as $(0 \cdots 0 \; 1)$.

Consider the constraint \ref{eq:tempvc} shown above. Say the above assumption about $\body \wedge \neg \post$ hold. 
Let $D$ be the $(n+1) \times (p+1)$ matrix $(D_0 \; D_1 \cdots D_k)^T$.
By Farkas' Lemma, a solution to constraint \ref{eq:tempvc} exists if
%
\begin{align}
\exists \Lambda \in \mathbb{R}^{p+1}. \; \Lambda \ge \zerovec \wedge \Lambda D =(0 \cdots 0 \; 1) \label{eq:flemma}
\end{align}
%
Since $D$ has only the template variables and constants, constraint~\ref{eq:flemma} is a non-linear constraint involving the template variables and lambdas. If there exists a model for constraint~\ref{eq:flemma} then the values of the template variables in the model 
are a valid solution for the constraint~\ref{eq:tempvc}.

\paragraph{Extensions for handling mixed strict and non-strict inequalities.}

In the above case we required that each $\sigma_k$ is of the form 
$D_k (x_1 \cdots x_n \; 1)^T \le 0$. However, it is possible to extend the approach to
also support strict inequalities using \emph{Motzkin's transposition theorem}.

Let $\body \wedge \neg \post$ be of the form 
$\bigwedge \limits_{k=1}^{p} \sigma_k(X,A) \wedge \bigwedge \limits_{k=p}^{p+q} \delta_k(X,A)$,
where $\sigma_k$'s are defined as before and $\delta_k$'s are of the form 
$D_j (x_1 \cdots x_n \; 1)^T < \zerovec$.
By Motzkin's transposition theorem, a solution to constraint \ref{eq:tempvc} exists if
%
\begin{align}
& \nonumber
\exists \Lambda_1 \in \mathbb{R}^{p+1}, \Lambda_2 \in \mathbb{R}^{q}, \Lambda = (\Lambda_1 \; \Lambda_2). \; \\ 
& \qquad \Lambda \ge \zerovec \wedge (\Lambda D =(0 \cdots 0 \; 1) \vee (\Lambda_2 > \zerovec \wedge \Lambda D = \zerovec)) \label{eq:motlemma}
\end{align}
%
Notice that we have disjunctions in the constraints if there are mixed strict and non-strict inequalities in the constraint~\ref{eq:tempvc}. 
%From an efficiency perspective reducing the number of strict inequalities could be beneficial.

\paragraph{Extensions for handling disjunctions in constraint~\ref{eq:tempvc}.}

Handling disjunctions in constraint~\ref{eq:tempvc} is straight forward. We first
convert $\body \wedge \neg \post$ in to a DNF formula $\bigvee_i d_i$.
Constraint~\ref{eq:tempvc} is equivalent to 
%
\begin{align}
\exists A. \forall X. (\bigvee_i d_i) \Rightarrow false \\
\equiv \exists A. \bigwedge_i (\forall X. \; d_i \Rightarrow false)
\end{align}
%
Let $L_i =  (\forall X. \; d_i \Rightarrow false)$. We use the above approach to generate non linear constraints $C_i$ for each $L_i$ and solve the conjunction $C: \bigwedge C_i$.
If there exists a model for $C$ then the values of $A$ in the model will satisfy the 
constraint~\ref{eq:tempvc}.

\subsection{Extending the approach to handle User Defined Functions}

%Handling functions
%- handling uninterpreted functions
%- handling user defined functions by unrolling and new vc generation.
%some experimental results/details (mention that the nonlinear constraints are solved using z3)

\bibliographystyle{acm}
\bibliography{SAVproject}

\end{document}