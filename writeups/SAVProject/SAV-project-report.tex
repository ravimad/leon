\documentclass[a4paper,10pt]{article}

\usepackage{amsmath}
\usepackage{amssymb}

\begin{document}
\title{SAV Project Report \\ Templates in Function Postconditions}
\author{Ravichandhran Kandhadai Madhavan \\ ravi.kandhadai@epfl.ch}
\maketitle

\newcommand{\dash}[1]{\overline{#1}}
\newcommand{\progst}[1]{\texttt{#1}}
\newcommand{\temp}{\mathit{\phi_{temp}}}
\newcommand{\post}{\mathit{\phi_{post}}}
\newcommand{\body}{\mathit{\phi_{body}}}
\newcommand{\zerovec}{\mathbf{0}}
%\newcommand{\implies}{\Rightarrow}

\input{genericmacros}

\section{Problem Definition}

In this project we enhance the flexibility of the Leon verification engine by allowing the users to specify abstract postconditions that state the property to be verified and also a linear template which is a boolean valued expression containing linear inequalities with unknown coefficients.
The unknown coefficients would be automatically bound to appropriate values so that the verification succeeds.
The domain of the unknown coefficients in the templates is fixed as the set of real numbers.

In the current implementation, the abstract postconditions are specified using the following syntax: \progst{ensuring(res => res != -1 template((a, b, c) => (a*res + b*x + c <= 0 \&\& b < 0)))}. Here, the property to be verified is \progst{res != -1} and the template is \progst{(a*res + b*x + c <= 0 \&\& b < 0)} where $a$, $b$ and $c$ are the unknown coefficients.

Figure 2, shows an example that uses the above abstract postcondition.
%
\begin{figure}
\begin{myprogram}
\pnl \> def s(x: Int) : Int = \{ \\
\pnl \> \> if(x < 0) \\
\pnl \> \> \> - x \\
\pnl \> \> else  \\
\pnl \> \> \> 	s(x-1) + x\\
\pnl \> \} ensuring(res => res != -1  \\
\pnl \> \> \> template((a,b,c) => (a*res + b*x + c <= 0 \&\& b<0)))
\end{myprogram}
\caption{A simple program with an abstract postcondition containing templates} \label{fig:eg}
\end{figure}
%
For this example, our implementation binds the unknown coefficients $a$,$b$ and $c$ to 
the values $-6$, $-2$ and $1$, respectively.

We focus only on numerical Leon programs that do not use any data structures. We also require that every arithmetic expression in the program (including pre and postconditions) to be a \emph{linear combination} of program variables and function invocations.

\section{The Approach}

%We now discuss our approach for handling the abstract postconditions discussed above.

\subsection{Verification condition generation for abstract postconditions}

An abstract postcondition with a property $\phi(X)$ and a template $\temp(X,A)$,
where $X$ is a row vector of program variables and $A$ is row a vector of unknown coefficients (also referred to as template variables),
represents the postcondition $\post(X,A): \phi(X) \wedge \temp(X,A)$.
Using this interpretation of the abstract postconditions we generate a verification condition 
for the program in the standard way. 
The verification condition would be of the form $\body(X,A) \Rightarrow \post(X,A)$. Notice that $\body$ may also use the template variables as the verification condition is generated by assuming the postcondition for the recursive calls in the body.
For the postcondition to hold we need the verification condition to be valid. Since the $A$'s can be bound to any real value the goal is to find an $A$ such that the verification condition is valid. Formally, we need to prove
%
\begin{align}
& \exists A. \forall X. \body(X,A) \Rightarrow \post(X,A) \\
& \equiv  \exists A. \forall X. \body(X,A) \wedge \neg(\post(X,A)) \Rightarrow \mathit{false}
\label{eq:tempvc}
\end{align}

In general, $\body$ and $\post$ can be arbitrary boolean valued expressions belonging to our language. Therefore, they can contain user-defined functions.
However, we first focus on a restrictive case where the predicates do not contain any user-defined functions and gradually extend the approach to handle all expressions belonging our language.

\subsection{Solving a restricted case using Farkas' and Motzkin's Lemmas}

Let $A = (a_1 \cdots a_m)$ and $X = (x_1 \cdots x_n)$.
Let $\body \wedge \neg \post$ be of the form 
$\bigwedge \limits_{k=1}^{p} \sigma_k(X,A)$ with each $\sigma_k$ of the form 
$D_k (x_1 \cdots x_n \; 1)^T \le \zerovec$ where $D_k$ is a row vector of $(n+1)$ elements
which are constants or template variables.
Define $D_0$ as $(0 \cdots 0 \; 1)$.

Consider the constraint \ref{eq:tempvc} shown above. Say the above assumption about $\body \wedge \neg \post$ hold. 
Let $D$ be the $(n+1) \times (p+1)$ matrix $(D_0 \; D_1 \cdots D_k)^T$.
By Farkas' Lemma, a solution to constraint \ref{eq:tempvc} exists if
%
\begin{align}
\exists A. \exists \Lambda \in \mathbb{R}^{p+1}. \; \Lambda \ge \zerovec \wedge \Lambda D =(0 \cdots 0 \; 1) \label{eq:flemma}
\end{align}
%
Since $D$ has only the template variables and constants, constraint~\ref{eq:flemma} is a non-linear constraint involving the template variables and lambdas. If there exists a model for constraint~\ref{eq:flemma} then the values of the template variables in the model 
are a valid solution for the constraint~\ref{eq:tempvc}.

\paragraph{Extensions for handling mixed strict and non-strict inequalities.}

In the above case we required that each $\sigma_k$ is of the form 
$D_k (x_1 \cdots x_n \; 1)^T \le 0$. However, it is possible to extend the approach to
also support strict inequalities using \emph{Motzkin's transposition theorem}.

Let $\body \wedge \neg \post$ be of the form 
$\bigwedge \limits_{k=1}^{p} \sigma_k(X,A) \wedge \bigwedge \limits_{k=p}^{p+q} \delta_k(X,A)$,
where $\sigma_k$'s are defined as before and $\delta_k$'s are of the form 
$D_k (x_1 \cdots x_n \; 1)^T < \zerovec$.
By Motzkin's transposition theorem, a solution to constraint \ref{eq:tempvc} exists if
%
\begin{align}
& \nonumber
\exists A. \exists \Lambda_1 \in \mathbb{R}^{p+1}, \Lambda_2 \in \mathbb{R}^{q}, \Lambda = (\Lambda_1 \; \Lambda_2). \; \\ 
& \qquad \Lambda \ge \zerovec \wedge (\Lambda D =(0 \cdots 0 \; 1) \vee (\Lambda_2 > \zerovec \wedge \Lambda D = \zerovec)) \label{eq:motlemma}
\end{align}
%
Notice that we have disjunctions in the constraints when there are mixed strict and non-strict inequalities in the constraint~\ref{eq:tempvc}. 
%From an efficiency perspective reducing the number of strict inequalities could be beneficial.

\subsection{Extensions for handling disjunctions in constraint~\ref{eq:tempvc}}

Handling disjunctions in constraint~\ref{eq:tempvc} is straight forward. We first
convert $\body \wedge \neg \post$ in to a DNF formula $\bigvee_i d_i$.
Constraint~\ref{eq:tempvc} is equivalent to 
%
\begin{align}
\exists A. \forall X. (\bigvee_i d_i) \Rightarrow false \\
\equiv \exists A. \bigwedge_i (\forall X. \; d_i \Rightarrow false)
\end{align}
%
Let $L_i =  (\forall X. \; d_i \Rightarrow false)$. We use the above approach to generate non linear constraints $C_i$ for each $L_i$ and solve the conjunction $C: \bigwedge C_i$.
If there exists a model for $C$ then the values of $A$ in the model will satisfy the 
constraint~\ref{eq:tempvc}.

\subsection{Extending the approach to handle User Defined Functions (UDFs) in the body}

The Leon verification framework proposes an approach for generating verification conditions in the presence of calls to UDFs in the function body (like in Figure~\ref{fig:eg} which has a recursive call in the body). In the Leon approach, the calls to the UDFs are treated as logical functions and retained in the verification condition. For example, $\body$ for the program shown in Figure~\ref{fig:eg} will  be of the form 
$(x < 0 \wedge res = -x) \vee (x \ge 0 \wedge res = s(x-1) + x \wedge a*s(x-1) + b*x + c \le 0 \wedge b < 0 \wedge s(x-1) \ne -1)$.

We handle such a verification condition containing UDFs iteratively. Each iteration consists of two phases. In the first phase, we treat the UDFs as uninterpreted functions (UIFs) and solve for the template variables.
If there exists a solution then we halt and return the solution (the correctness of the solution is evident).
If a solution does not exist, we proceed to the \emph{unrolling} phase which refines the verification condition using the definition of the called function and passes it to the 
first phase. We now explain the phases in detail.

\paragraph{Solving constraint~\ref{eq:tempvc} with uninterpreted functions.}

%TODO find the precise definition of equisatisfiability

Say $\body$ and $\post$ in constraint~\ref{eq:tempvc} contain uninterpreted functions.
Let $\psi(X,A): \body(X,A) \wedge \neg \post(X,A)$.
Without loss of generality assume that $\psi$ is a conjunction of atomic predicates.
As discussed in the earlier section, in the presence of disjunctions,  the problem can be reduced to sub-problems having this form.

We first convert $\psi$, by introducing fresh variables say $X'$, 
to a equvisatisfiable formula $\psi_{I}(X,X',A) \wedge \psi_{F}(X,X',A)$ in which
$\psi_I$ is a formula without UIFs and 
$\psi_{F}$ is of the form $\bigwedge_i (v_i = f_i(Y_i))$ where, $f_i$ is a function symbol,  
$v_i \in X \cup X'$ is either a program variable or a newly introduced fresh variable 
and $Y_i \in (X \cup X')^n$ is a vector of program variables and fresh variables.  
Clearly, constraint~\ref{eq:tempvc} is equivalent to 
%
\begin{align}
\exists A. \forall X,X'. \; \psi_{I}(X,X',A) \wedge \psi_{F}(X,X',A) \label{eq:c2}
\end{align}

In the above constraint the UIFs in $\psi_{F}$ can be eliminated using the axiom of uninterpreted functions which states that the result of  two functions are equal if the functions have the same name and the arguments are equal. 
Let,
\begin{align}
\psi_R = \bigwedge \left\lbrace (\bigwedge \limits_{j=1}^{n} y_j = z_j) \Rightarrow v = u \vbar \exists f. v = f(y_1,\cdots,y_n), u = f(z_1,\cdots,z_n) \in \phi_F \right\rbrace
\end{align}

Note that $\psi_R$ does not have any UIFs. By the axiom of uninterpreted functions,  constraint~\ref{eq:c2} is equivalent to 
%
\begin{align}
\exists A. \forall X,X'. \; \psi_{I}(X,X',A) \wedge \psi_{R}(X,X',A) \label{eq:c3}
\end{align}
%
Constraint~\ref{eq:c3} can be solved using the approach discussed earlier as it is completely numerical. A model for constraint~\ref{eq:c3} is a valid model for constraint~\ref{eq:tempvc}.

%- handling user defined functions by unrolling and new vc generation.
%some experimental results/details (mention that the nonlinear constraints are solved using z3)

\bibliographystyle{acm}
\bibliography{SAVproject}

\end{document}