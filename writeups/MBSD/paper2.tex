\newcommand{\next}{\bigcirc}
\newcommand{\until}{\mathcal{\; U \;}}
\newcommand{\eventually}{\diamond}
\renewcommand{\eventually}{\diamondsuit}
\newcommand{\always}{\square}

\section{Paper 2: Temporal-Logic-Based Reactive Mission and Monitor Planning \cite{gazit:95}} \label{sec:paper2}

The paper considers the problem of synthesizing transition systems for robotic motion from the 
high-level specifications  provided in linear time temporal logic (LTL). The paper proposes  
(a) a specification language that is a restriction of LTL for specifying the motion of a robot
and also the environment in which it operates.  
(b) a technique for automatically generating a discrete automaton for the robot motion, using the 
existing approaches, that satisfies the specification of the robot when the environment behaves as specified. 
(c) an algorithm for converting the generated discrete automaton to a hybrid automaton that interacts 
continuously with the environment.
(d) a compositional and decentralized method for generating multirobot tasks using \emph{assume guarantee reasoning}.

\textbf{Specifying the motion of a robot and the environments using GR(1) formula:}

\textit{Robot Model:} Consider a robot that is operating in a polygonal space $P$ that 
has several partitions, namely, $P_1,P_2 \cdots P_n$. $p(t)$ is the position of the robot at time $t$
and $u(t)$ is the control input which can be used to move the robot to the desired location. 
$p(t) \in P \subseteq \real^2$ and $u(t) \in \real^2$. 
$\{ r_1,\cdots,r_n \}$ is a set of propositions such that $r_i$ is $true$ iff the robot is in  partition $P_i$.
The robot can perform $k$ actions given by $A$.  For all $1 \le i \le k$, a proposition $a_i$ is true if the
action $i$ is being executed.
Let $Y = \{ r_1,\cdots,r_n, a_1,\cdots,a_k \}$ denote the set of robot propositions.

\textit{Environment Model:}
The robot interacts with the environment through $m$ binary sensors whose values are captured by 
the variables $X = \{ x_i \vbar 1 \le i \le m\}$. 
The behavior of the environment is specified using a LTL formula over the sensor variables.

\textit{Specification Language:} Let $AP = X \cup Y$  denote the set of atomic propositions.
The syntax of the LTL formulas over the set of atomic propositions is given by the following grammar:
\[ \varphi ::= \pi \in AP \vbar \neg \phi \vbar \phi \vee \phi \vbar  \next \phi \vbar \phi \until \phi  \]
where $\next$ represents the next operator and $\until$ the until operator.
Define  the "Eventually" operator $\eventually \phi$ as $true \until \phi$ and the 
always operator $\always \phi$ as $\neg \eventually \neg \phi$.

The paper focuses on a special class of LTL formulas called \emph{generalized reactivity formula}(GR(1)) formula
that have the following form: $\phi_e \Rightarrow \phi_s$  where $\phi_e$ is the assumption
about the environment and $\phi_s$ is the desired behavior of the robot.
$\phi_e$ and $\phi_s$ should have the following structure $\phi_i \wedge \phi_t \wedge \phi_g$ where
$\phi_i$ is a nontemporal formula defined over $X$ for $\phi_e$ and over $Y$ for $\phi_s$. 
$\phi_t$ is a temporal formula of the form $\square B_i$ (always $B_i$) where $B_i$ is a formula 
defined over $X \cup Y \cup \next X$ for $\phi_e$ and over $X \cup Y \cup \next X \cup \next Y$ for
$\phi_s$. Finally, $\phi_g$ captures the invariants of the environment and the goal of the robot 
and is of the form $\always \eventually B_i$
where $B_i$ is defined over $X \cup Y$ for both $\phi_e$ and $\phi_s$.

\newcommand{\shoot}{\mathit{a^{shoot}}}
\newcommand{\duck}{\mathit{s^{duck}}}
\newcommand{\collect}[1]{\mathit{s^{collect_{#1}}}}

\textit{Duck Hunting:} The paper discusses an example in which a robot's task is to find \emph{Nemo}.
In this report we consider a different interesting example in which the robot is stationary but
it has to visually scan through the space in its perspective and look for ducks that may occasionally 
fly through the space. The task of the robot is fire a shot directed towards the duck on detecting one.

Assume that the robot has a 2D vision and the space in front of the robot is divided into a $4 \times 4$ grid.
The robot scans the grid, column by column, starting from the left bottom. 
The $(i,j)^{th}$ cell of the grid corresponds to a proposition $r_{ij}$.
The robot is fitted with a gun and can direct a shot towards a target in a grid which can be activated 
by the proposition $\shoot$. The robot detects a duck in a grid with a sensor $\duck$.
Initially, the robot starts at the grid position $(1,1)$ (left bottom).

We first specify the assumptions on the environment $\phi_e = {\phi_i}^e \wedge {\phi_t}^e \wedge {\phi_g}^e$.
${\phi_i}^e = \neg \duck$ i.e, initially there is no duck. 
A duck never stays in a grid it moves continuously. Therefore,
${\phi_t}^e = \bigwedge_{i,j} \always (r_{ij} \wedge \duck \Rightarrow \neg \next \duck)$.
${\phi_g}^e = \always \eventually true$.

We now specify the behavior of the robot $\phi_s = {\phi_i}^s \wedge {\phi_t}^s \wedge {\phi_g}^s$.
${\phi_i}^s = r_{1,1} \wedge \neg \shoot$ i.e, initially the robot scans the grid $(1,1)$ and does not shoot.
${\phi_t}^s$ has three components, the first specifies the possible transitions, the second specifies the
mutual exclusion property that the robot scans atmost one square at a time and the final component 
specifies that the robot should shoot if and only if it finds the duck in a grid.
%
\begin{align*}
{\phi_t}^s = 
\begin{cases}
\begin{cases}
\bigwedge_{i,j} \always (r_{ij} \wedge j < 4 \Rightarrow \next r_{i(j+1)}) \wedge  \\
\qquad  \always (r_{ij} \wedge j=4 \wedge i<4 \Rightarrow \next r_{(i+1)1}) \wedge  \\
\qquad \always (r_{ij} \wedge i=4 \wedge j=4 \Rightarrow \next r_{11}) 
\end{cases} \\
%
\begin{cases}
\bigwedge_{i,j} \always (\next r_{ij} \Rightarrow \bigwedge_{p \ne i,q \ne j} \neg \next r_{pq})
\end{cases} \\
%
\begin{cases}
\always (\next \duck \Rightarrow \next \shoot) \wedge \\
\always (\neg \next \duck \Rightarrow \neg \next \shoot) 
\end{cases} 
\end{cases}
\end{align*}
%
Finally, we need to state that the robot scans all the grids forever. Therefore, 
${\phi_g}^s = \bigwedge_{i,j} \always \eventually r_{i,j}$.

\textbf{Generating Automaton from Specifications:}
The paper uses the approach discussed in \cite{pnueli:VMCAI06} to generate an automaton (which is a combination
of labelled transition systems and kripke structures) in which the sensor propositions $X$ appear 
in the transitions and the robot propositions $Y$ are associated with states. 
The automaton construction happens in $O(n^3)$ time where $n$ is the number of states in the generated
automaton. However, the number of states could be exponential in the size of the specification.
The papers proposes a straight forward algorithm for converting the discrete automaton into a
hybrid automaton that continuously interacts with the environment and instructs the robot actions.
In general, the method is guaranteed to work correctly as long as the environment satisfies its specifications.

\textbf{Handling multirobot scenarios:}
The paper proposes to extend the approach to multirobot scenarios in a compositional and decentralized way.
In this method each robot is provided its own specification as before. However, in order for the 
robots to interact, new sensor propositions are introduced. The robots may communicate by setting/resetting 
the sensor propositions.

For instance, in our example, say we want to add a robot to collect the ducks that are shot. Assume that
whenever a duck is shot in a grid $(i,j)$ it falls to the place on the ground given by the x coordinate 
$i$. The second robot could move along the x axis and collect the shot ducks.
It has the propositions $\{ r_1,\cdots,r_4 \}$  corresponding to the x coordinates.
We introduce  new sensor predicates say $\collect{i}$, $1 \le i \le 4$.
When the first robot shoots a duck in a grid $(i,j)$ it sets the sensor proposition $\collect{i}$ to
true. The second robot moves to the location $r_i$ if the sensor proposition $\collect{i}$ is set.
The second robot may also have an action $a^{pick}$  that picks the shot duck.
It is straight forward to express these properties as GR(1) formulas as described above.