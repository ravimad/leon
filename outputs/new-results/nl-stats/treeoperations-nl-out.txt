New Prog: 
object TreeOperations {
  case class Nil() extends List

  sealed abstract class Tree

  case class Leaf() extends Tree

  case class Node(left: Tree, value: Int, right: Tree) extends Tree

  case class Cons(head: Int, tail: List) extends List

  sealed abstract class List

  def contains1(elem : Int, t : Tree) : (Boolean, Int) = {locally {
    val t95 = 1
    if (t.isInstanceOf[Leaf]) {
      (false, t95)
    } else {
      locally {
        val (e89: Boolean, t97: Int) = locally {
          val t98 = 2
          if ((t.value == elem)) {
            (true, t98)
          } else {
            locally {
              val (e92: Boolean, t100: Int) = locally {
                val t101 = 2
                if ((t.value < elem)) {
                  locally {
                    val (e94: Boolean, t102: Int) = locally {
                      val (e97: Boolean, t105: Int) = contains1(elem, t.right)
                      (e97, (1 + (1 + t105)))
                    }
                    
                    (e94, (t101 + t102))
                  }
                  
                } else {
                  locally {
                    val (e99: Boolean, t107: Int) = locally {
                      val (e102: Boolean, t110: Int) = contains1(elem, t.left)
                      (e102, (1 + (1 + t110)))
                    }
                    
                    (e99, (t101 + t107))
                  }
                  
                }
              }
              
              (e92, (t98 + t100))
            }
            
          }
        }
        
        (e89, (t95 + t97))
      }
      
    }
  }
  } ensuring(res4 => true)

  def mult1(x : Int, y : Int) : Int = {if (((x == 0) || (y == 0))) {
    0
  } else {
    (((mult1((x - 1), (y - 1)) + x) + y) - 1)
  }}

  def height1(t : Tree) : Int = {(t match {
    case Leaf() =>
      0
    case Node(l, x, r) =>
      locally {
        val hl = height1(l)
        locally {
          val hr = height1(r)
          if ((hl > hr)) {
            (hl + 1)
          } else {
            (hr + 1)
          }
        }
        
      }
      
  })}

  def listSize1(l : List) : Int = {(l match {
    case Nil() =>
      0
    case Cons(_, t) =>
      (1 + listSize1(t))
  })}

  def addAll1(l : List, t : Tree) : Tree = {(l match {
    case Nil() =>
      t
    case Cons(x, xs) =>
      locally {
        val newt = insert1(x, t)._1
        addAll1(xs, newt)
      }
      
  })}

  def insert1(elem : Int, t : Tree) : (Tree, Int) = {locally {
    val t119 = 1
    if (t.isInstanceOf[Leaf]) {
      (Node(Leaf(), elem, Leaf()), (t119 + 3))
    } else {
      locally {
        val (e116: Node, t124: Int) = locally {
          val t125 = 2
          if ((t.value <= elem)) {
            locally {
              val (e118: Node, t126: Int) = locally {
                val (e121: Tree, t129: Int) = locally {
                  val (e124: Tree, t132: Int) = insert1(elem, t.right)
                  (e124, (1 + (1 + t132)))
                }
                
                (Node(t.left, t.value, e121), (t129 + 3))
              }
              
              (e118, (t125 + t126))
            }
            
          } else {
            locally {
              val (e128: Node, t136: Int) = locally {
                val (e129: Tree, t137: Int) = locally {
                  val (e136: Tree, t144: Int) = insert1(elem, t.left)
                  (e136, (1 + (1 + t144)))
                }
                
                (Node(e129, t.value, t.right), (1 + (1 + (t137 + 1))))
              }
              
              (e128, (t125 + t136))
            }
            
          }
        }
        
        (e116, (t119 + t124))
      }
      
    }
  }
  } ensuring(res5 => (height1(res5._1) <= (height1(t) + 1)))

  def removeAll1(l : List, t : Tree) : Tree = {(l match {
    case Nil() =>
      t
    case Cons(x, xs) =>
      removeAll1(xs, remove1(x, t)._1)
  })}

  def remove1(elem : Int, t : Tree) : (Tree, Int) = {locally {
    val t8 = 1
    if (t.isInstanceOf[Leaf]) {
      (Leaf(), (t8 + 1))
    } else {
      locally {
        val (e2: Tree, t10: Int) = locally {
          val t11 = 2
          if ((t.value < elem)) {
            locally {
              val (e4: Node, t12: Int) = locally {
                val (e7: Tree, t15: Int) = locally {
                  val (e10: Tree, t18: Int) = remove1(elem, t.right)
                  (e10, (1 + (1 + t18)))
                }
                
                (Node(t.left, t.value, e7), (t15 + 3))
              }
              
              (e4, (t11 + t12))
            }
            
          } else {
            locally {
              val (e14: Tree, t22: Int) = locally {
                val t23 = 2
                if ((t.value > elem)) {
                  locally {
                    val (e16: Node, t24: Int) = locally {
                      val (e17: Tree, t25: Int) = locally {
                        val (e24: Tree, t32: Int) = remove1(elem, t.left)
                        (e24, (1 + (1 + t32)))
                      }
                      
                      (Node(e17, t.value, t.right), (1 + (1 + (t25 + 1))))
                    }
                    
                    (e16, (t23 + t24))
                  }
                  
                } else {
                  locally {
                    val (e26: Tree, t34: Int) = locally {
                      val t35 = 6
                      if ((t.isInstanceOf[Node] && t.left.isInstanceOf[Leaf] && t.right.isInstanceOf[Leaf])) {
                        (Leaf(), (t35 + 1))
                      } else {
                        locally {
                          val (e29: Tree, t37: Int) = locally {
                            val t38 = 6
                            if ((t.isInstanceOf[Node] && t.left.isInstanceOf[Leaf] && t.right.isInstanceOf[Node])) {
                              locally {
                                val (e31: Node, t39: Int) = locally {
                                  val (e34: Tree, t42: Int) = locally {
                                    val (e37: Tree, t45: Int) = remove1(t.right.value, t.right)
                                    (e37, (1 + (2 + (1 + t45))))
                                  }
                                  
                                  (Node(Leaf(), t.right.value, e34), (t42 + 4))
                                }
                                
                                (e31, (t38 + t39))
                              }
                              
                            } else {
                              locally {
                                val (e43: Tree, t51: Int) = locally {
                                  val t52 = 4
                                  if ((t.isInstanceOf[Node] && t.left.isInstanceOf[Node])) {
                                    locally {
                                      val (e45: Node, t53: Int) = locally {
                                        val (e46: Tree, t54: Int) = locally {
                                          val (e54: Tree, t62: Int) = remove1(t.left.value, t.left)
                                          (e54, (1 + (2 + (1 + t62))))
                                        }
                                        
                                        (Node(e46, t.left.value, t.right), (1 + (2 + (t54 + 1))))
                                      }
                                      
                                      (e45, (t52 + t53))
                                    }
                                    
                                  } else {
                                    (Leaf(), (t52 + 1))
                                  }
                                }
                                
                                (e43, (t38 + t51))
                              }
                              
                            }
                          }
                          
                          (e29, (t35 + t37))
                        }
                        
                      }
                    }
                    
                    (e26, (t23 + t34))
                  }
                  
                }
              }
              
              (e14, (t11 + t22))
            }
            
          }
        }
        
        (e2, (t8 + t10))
      }
      
    }
  }
  } ensuring(res3 => true)

  def size1(t : Tree) : Int = {(t match {
    case Leaf() =>
      0
    case Node(l, x, r) =>
      ((size1(l) + size1(r)) + 1)
  })}
}

[[34m Info  [0m] Running Invariant Inference Phase...
[[34m Info  [0m] Analysis Order: List(height1, size1, mult1, insert1, contains1, addAll1, remove1, removeAll1, listSize1)
[[34m Info  [0m] - considering function insert1...
[[34m Info  [0m] Body: if (t.isInstanceOf[Leaf])
            (Node(Leaf(), elem, Leaf()), (1 + 3))
          else
            (let (e116,t124 := if ((t.value ≤ elem))
              (let (e118,t126 := (let (e121,t129 := (let (e124,t132 := insert1(elem, t.right)) in
                (e124, (1 + (1 + t132))))) in
                (Node(t.left, t.value, e121), (t129 + 3)))) in
                (e118, (2 + t126)))
            else
              (let (e128,t136 := (let (e129,t137 := (let (e136,t144 := insert1(elem, t.left)) in
                (e136, (1 + (1 + t144))))) in
                (Node(e129, t.value, t.right), (1 + (1 + (t137 + 1)))))) in
                (e128, (2 + t136)))) in
              (e116, (1 + t124)))
[[34m Info  [0m] Post: (height1(res5._1) ≤ (height1(t) + 1))
falttened Body: ((res5 == ifres) ∧ (t119 == 1) ∧ ((ci ∧ (ci <=> t.isInstanceOf[Leaf]) ∧ (ifres == tp) ∧ (cc2 == Node(cc, elem, cc1)) ∧ (tp == (cc2, arg)) ∧ (cc1 == Leaf()) ∧ (cc == Leaf()) ∧ (arg == (t119 + 3))) ∨ (¬(ci1) ∧ (ci1 <=> t.isInstanceOf[Leaf]) ∧ (ifres == tp1) ∧ (arg1 == (t119 + t124)) ∧ (tp1 == (e116, arg1)) ∧ (t125 == 2) ∧ (((cs ≤ elem) ∧ (cs == t.value) ∧ (ifres1 == tp2) ∧ (arg2 == (t125 + t126)) ∧ (tp2 == (e118, arg2)) ∧ (e118 == cc3) ∧ (cs1 == t.left) ∧ (cs2 == t.value) ∧ (cc3 == Node(cs1, cs2, e121)) ∧ (e121 == e124) ∧ (e124 == ts1) ∧ (ts1 == tres._1) ∧ (t129 == (1 + (1 + t132))) ∧ (t126 == (t129 + 3)) ∧ (t132 == ts2) ∧ (ts2 == tres._2) ∧ (tres == r8) ∧ (cs3 == t.right) ∧ (r8 == insert1(elem, cs3))) ∨ ((cs4 > elem) ∧ (cs4 == t.value) ∧ (ifres1 == tp3) ∧ (arg3 == (t125 + t136)) ∧ (tp3 == (e128, arg3)) ∧ (t136 == (1 + (1 + (t137 + 1)))) ∧ (tres1 == r9) ∧ (cs5 == t.left) ∧ (r9 == insert1(elem, cs5)) ∧ (e129 == e136) ∧ (t137 == (1 + (1 + t144))) ∧ (e128 == cc4) ∧ (cs6 == t.value) ∧ (cs7 == t.right) ∧ (cc4 == Node(e129, cs6, cs7)) ∧ (e136 == ts3) ∧ (ts3 == tres1._1) ∧ (t144 == ts4) ∧ (ts4 == tres1._2))) ∧ (e116 == ts5) ∧ (ts5 == ifres1._1) ∧ (t124 == ts6) ∧ (ts6 == ifres1._2))))
Flattened Post: (((r6 > (r7 + 1)) ∧ (ts == res5._1) ∧ (r6 == height1(ts)) ∧ (r7 == height1(t))) ∨ ((ts7 > ((a? * r10) + b?)) ∧ (ts7 == res5._2) ∧ (r10 == height1(t))))
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
insert1-->((((1 * res5._2) + (0 * height1(t))) + 0) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 2
[[34m Info  [0m] Number of equal calls: 2
# of atomic predicates: 9
solving...
solved... in 0.009s
candidate Invariants
insert1-->((((1 * res5._2) + (0 * height1(t))) + -6) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 3
[[34m Info  [0m] Number of equal calls: 2
# of atomic predicates: 0
solving...
solved... in 0.006s
[[34m Info  [0m] - More unrollings for invariant inference
Creating VC for height1
[[34m Info  [0m] - Number of new terms enumerated: 2
[[34m Info  [0m] - Template generated for function height1 : (((a?4 * #res) + a?3) ≤ 0)
Unrolling (r10 == height1(t))
Unrolling (r11 == height1(cs3))
Unrolling (r12 == height1(cs5))
Unrolling (r9 == insert1(elem, cs5))
Unrolling (r7 == height1(t))
Unrolling (r8 == insert1(elem, cs3))
Unrolling (r6 == height1(ts))
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
insert1-->((((1 * res5._2) + (0 * height1(t))) + 0) ≤ 0)
height1-->(((0 * #res) + 0) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 248
[[34m Info  [0m] Number of equal calls: 28
# of atomic predicates: 32
solving...
solved... in 0.01s
candidate Invariants
insert1-->((((2 * res5._2) + (-6 * height1(t))) + -1) ≤ 0)
height1-->(((0 * #res) + 11) ≤ 0)
Function: height1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 8
solving...
solved... in 0.011s
candidate Invariants
insert1-->((((-34 * height1(t)) + (2 * res5._2)) + 1) ≤ 0)
height1-->(((0 * #res) + -1) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 2
[[34m Info  [0m] Number of equal calls: 2
# of atomic predicates: 10
solving...
solved... in 0.011s
candidate Invariants
insert1-->((((-21 * height1(t)) + (1 * res5._2)) + -7) ≤ 0)
height1-->(((0 * #res) + -1) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: insert1 --> ((((1 * res5._2) + (-21 * height1(t))) + -7) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: height1 --> (((0 * #res) + -1) ≤ 0)
[[34m Info  [0m] - Verifying Invariants... 
[[34m Info  [0m] - Invariant verified
[[34m Info  [0m] - considering function contains1...
[[34m Info  [0m] Body: if (t.isInstanceOf[Leaf])
            (false, 1)
          else
            (let (e89,t97 := if ((t.value == elem))
              (true, 2)
            else
              (let (e92,t100 := if ((t.value < elem))
                (let (e94,t102 := (let (e97,t105 := contains1(elem, t.right)) in
                  (e97, (1 + (1 + t105))))) in
                  (e94, (2 + t102)))
              else
                (let (e99,t107 := (let (e102,t110 := contains1(elem, t.left)) in
                  (e102, (1 + (1 + t110))))) in
                  (e99, (2 + t107)))) in
                (e92, (2 + t100)))) in
              (e89, (1 + t97)))
[[34m Info  [0m] Post: true
falttened Body: ((res4 == ifres12) ∧ (t95 == 1) ∧ ((ci18 ∧ (ci18 <=> t.isInstanceOf[Leaf]) ∧ (ifres12 == tp12) ∧ ¬(arg12) ∧ (tp12 == (arg12, t95))) ∨ (¬(ci19) ∧ (ci19 <=> t.isInstanceOf[Leaf]) ∧ (ifres12 == tp13) ∧ (arg13 == (t95 + t97)) ∧ (tp13 == (e89, arg13)) ∧ (t98 == 2) ∧ (((cs36 == elem) ∧ (cs36 == t.value) ∧ (ifres13 == tp14) ∧ arg14 ∧ (tp14 == (arg14, t98))) ∨ ((((cs37 < elem) ∧ (cs37 == t.value)) ∨ ((cs38 > elem) ∧ (cs38 == t.value))) ∧ (ifres13 == tp15) ∧ (arg15 == (t98 + t100)) ∧ (tp15 == (e92, arg15)) ∧ (t101 == 2) ∧ (((cs39 < elem) ∧ (cs39 == t.value) ∧ (ifres14 == tp16) ∧ (arg16 == (t101 + t102)) ∧ (tp16 == (e94, arg16)) ∧ (t102 == (1 + (1 + t105))) ∧ (t105 == ts35) ∧ (ts35 == tres6._2) ∧ (¬(e97) ∨ (ts36 ∧ (ts36 <=> tres6._1))) ∧ ((¬(ts37) ∧ (ts37 <=> tres6._1)) ∨ e97) ∧ (¬(e94) ∨ e97) ∧ (¬(e97) ∨ e94) ∧ (tres6 == r50) ∧ (cs40 == t.right) ∧ (r50 == contains1(elem, cs40))) ∨ ((cs41 ≥ elem) ∧ (cs41 == t.value) ∧ (ifres14 == tp17) ∧ (arg17 == (t101 + t107)) ∧ (tp17 == (e99, arg17)) ∧ (t110 == ts38) ∧ (ts38 == tres7._2) ∧ (¬(e99) ∨ e102) ∧ (¬(e102) ∨ e99) ∧ (tres7 == r51) ∧ (cs42 == t.left) ∧ (r51 == contains1(elem, cs42)) ∧ (t107 == (1 + (1 + t110))) ∧ (¬(e102) ∨ (ts39 ∧ (ts39 <=> tres7._1))) ∧ ((¬(ts40) ∧ (ts40 <=> tres7._1)) ∨ e102))) ∧ (¬(e92) ∨ (ts41 ∧ (ts41 <=> ifres14._1))) ∧ ((¬(ts42) ∧ (ts42 <=> ifres14._1)) ∨ e92) ∧ (t100 == ts43) ∧ (ts43 == ifres14._2))) ∧ (¬(e89) ∨ (ts44 ∧ (ts44 <=> ifres13._1))) ∧ ((¬(ts45) ∧ (ts45 <=> ifres13._1)) ∨ e89) ∧ (t97 == ts46) ∧ (ts46 == ifres13._2))))
Flattened Post: ((ts47 > ((a?2 * r52) + b?2)) ∧ (ts47 == res4._2) ∧ (r52 == height1(t)))
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
contains1-->((((1 * res4._2) + (0 * height1(t))) + 0) ≤ 0)
Function: contains1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 59
[[34m Info  [0m] Number of equal calls: 9
# of atomic predicates: 36
solving...
solved... in 0.008s
[[34m Info  [0m] - More unrollings for invariant inference
Unrolling (r50 == contains1(elem, cs40))
Creating VC for height1
Unrolling (r53 == height1(cs40))
Unrolling (r52 == height1(t))
Unrolling (r54 == height1(cs42))
Unrolling (r51 == contains1(elem, cs42))
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
contains1-->((((1 * res4._2) + (0 * height1(t))) + 0) ≤ 0)
height1-->(((0 * #res) + 0) ≤ 0)
Function: contains1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 277
[[34m Info  [0m] Number of equal calls: 24
# of atomic predicates: 120
solving...
solved... in 0.018s
candidate Invariants
contains1-->((((2 * res4._2) + (-784 * height1(t))) + 1) ≤ 0)
height1-->(((2 * #res) + 8) ≤ 0)
Function: contains1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 16
[[34m Info  [0m] Number of equal calls: 5
Function: height1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 26
solving...
solved... in 0.031s
candidate Invariants
contains1-->((((-50 * height1(t)) + (1 * res4._2)) + -6) ≤ 0)
height1-->(((-1 * #res) + -1) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: contains1 --> ((((-50 * height1(t)) + (1 * res4._2)) + -6) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: height1 --> (((-1 * #res) + -1) ≤ 0)
[[34m Info  [0m] - Verifying Invariants... 
[[34m Info  [0m] - Invariant verified
[[34m Info  [0m] - considering function remove1...
[[34m Info  [0m] Body: if (t.isInstanceOf[Leaf])
            (Leaf(), (1 + 1))
          else
            (let (e2,t10 := if ((t.value < elem))
              (let (e4,t12 := (let (e7,t15 := (let (e10,t18 := remove1(elem, t.right)) in
                (e10, (1 + (1 + t18))))) in
                (Node(t.left, t.value, e7), (t15 + 3)))) in
                (e4, (2 + t12)))
            else
              (let (e14,t22 := if ((t.value > elem))
                (let (e16,t24 := (let (e17,t25 := (let (e24,t32 := remove1(elem, t.left)) in
                  (e24, (1 + (1 + t32))))) in
                  (Node(e17, t.value, t.right), (1 + (1 + (t25 + 1)))))) in
                  (e16, (2 + t24)))
              else
                (let (e26,t34 := if ((t.isInstanceOf[Node] ∧ t.left.isInstanceOf[Leaf] ∧ t.right.isInstanceOf[Leaf]))
                  (Leaf(), (6 + 1))
                else
                  (let (e29,t37 := if ((t.isInstanceOf[Node] ∧ t.left.isInstanceOf[Leaf] ∧ t.right.isInstanceOf[Node]))
                    (let (e31,t39 := (let (e34,t42 := (let (e37,t45 := remove1(t.right.value, t.right)) in
                      (e37, (1 + (2 + (1 + t45)))))) in
                      (Node(Leaf(), t.right.value, e34), (t42 + 4)))) in
                      (e31, (6 + t39)))
                  else
                    (let (e43,t51 := if ((t.isInstanceOf[Node] ∧ t.left.isInstanceOf[Node]))
                      (let (e45,t53 := (let (e46,t54 := (let (e54,t62 := remove1(t.left.value, t.left)) in
                        (e54, (1 + (2 + (1 + t62)))))) in
                        (Node(e46, t.left.value, t.right), (1 + (2 + (t54 + 1)))))) in
                        (e45, (4 + t53)))
                    else
                      (Leaf(), (4 + 1))) in
                      (e43, (6 + t51)))) in
                    (e29, (6 + t37)))) in
                  (e26, (2 + t34)))) in
                (e14, (2 + t22)))) in
              (e2, (1 + t10)))
[[34m Info  [0m] Post: true
falttened Body: ((res3 == ifres25) ∧ (t8 == 1) ∧ ((ci32 ∧ (ci32 <=> t.isInstanceOf[Leaf]) ∧ (ifres25 == tp30) ∧ (cc15 == Leaf()) ∧ (arg30 == (t8 + 1)) ∧ (tp30 == (cc15, arg30))) ∨ (¬(ci33) ∧ (ci33 <=> t.isInstanceOf[Leaf]) ∧ (ifres25 == tp31) ∧ (arg31 == (t8 + t10)) ∧ (tp31 == (e2, arg31)) ∧ (t11 == 2) ∧ (((cs65 < elem) ∧ (cs65 == t.value) ∧ (ifres26 == tp32) ∧ (arg32 == (t11 + t12)) ∧ (tp32 == (e4, arg32)) ∧ (t12 == (t15 + 3)) ∧ (e4 == cc16) ∧ (cs66 == t.left) ∧ (cs67 == t.value) ∧ (cc16 == Node(cs66, cs67, e7)) ∧ (e10 == ts83) ∧ (ts83 == tres12._1) ∧ (tres12 == r80) ∧ (cs68 == t.right) ∧ (r80 == remove1(elem, cs68)) ∧ (t15 == (1 + (1 + t18))) ∧ (t18 == ts84) ∧ (ts84 == tres12._2) ∧ (e7 == e10)) ∨ ((cs69 ≥ elem) ∧ (cs69 == t.value) ∧ (ifres26 == tp33) ∧ (arg33 == (t11 + t22)) ∧ (tp33 == (e14, arg33)) ∧ (t23 == 2) ∧ (((cs70 > elem) ∧ (cs70 == t.value) ∧ (ifres27 == tp34) ∧ (arg34 == (t23 + t24)) ∧ (tp34 == (e16, arg34)) ∧ (e16 == cc17) ∧ (cs71 == t.value) ∧ (cs72 == t.right) ∧ (cc17 == Node(e17, cs71, cs72)) ∧ (e24 == ts85) ∧ (ts85 == tres13._1) ∧ (t25 == (1 + (1 + t32))) ∧ (t32 == ts86) ∧ (ts86 == tres13._2) ∧ (tres13 == r81) ∧ (cs73 == t.left) ∧ (r81 == remove1(elem, cs73)) ∧ (t24 == (1 + (1 + (t25 + 1)))) ∧ (e17 == e24)) ∨ ((cs74 ≤ elem) ∧ (cs74 == t.value) ∧ (ifres27 == tp35) ∧ (arg35 == (t23 + t34)) ∧ (tp35 == (e26, arg35)) ∧ (t35 == 6) ∧ ((ci34 ∧ (ci34 <=> t.isInstanceOf[Node]) ∧ ci35 ∧ (cs75 == t.left) ∧ (ci35 <=> cs75.isInstanceOf[Leaf]) ∧ ci36 ∧ (cs76 == t.right) ∧ (ci36 <=> cs76.isInstanceOf[Leaf]) ∧ (ifres28 == tp36) ∧ (cc18 == Leaf()) ∧ (arg36 == (t35 + 1)) ∧ (tp36 == (cc18, arg36))) ∨ (((¬(ci37) ∧ (ci37 <=> t.isInstanceOf[Node])) ∨ (¬(ci38) ∧ (cs77 == t.left) ∧ (ci38 <=> cs77.isInstanceOf[Leaf])) ∨ (¬(ci39) ∧ (cs78 == t.right) ∧ (ci39 <=> cs78.isInstanceOf[Leaf]))) ∧ (ifres28 == tp37) ∧ (arg37 == (t35 + t37)) ∧ (tp37 == (e29, arg37)) ∧ (t38 == 6) ∧ ((ci40 ∧ (ci40 <=> t.isInstanceOf[Node]) ∧ ci41 ∧ (cs79 == t.left) ∧ (ci41 <=> cs79.isInstanceOf[Leaf]) ∧ ci42 ∧ (cs80 == t.right) ∧ (ci42 <=> cs80.isInstanceOf[Node]) ∧ (ifres29 == tp38) ∧ (arg38 == (t38 + t39)) ∧ (tp38 == (e31, arg38)) ∧ (t42 == (1 + (2 + (1 + t45)))) ∧ (e31 == cc20) ∧ (cc19 == Leaf()) ∧ (cs81 == t.right) ∧ (cs82 == cs81.value) ∧ (cc20 == Node(cc19, cs82, e34)) ∧ (tres14 == r82) ∧ (cs83 == t.right) ∧ (cs84 == cs83.value) ∧ (cs85 == t.right) ∧ (r82 == remove1(cs84, cs85)) ∧ (e37 == ts87) ∧ (ts87 == tres14._1) ∧ (t39 == (t42 + 4)) ∧ (t45 == ts88) ∧ (ts88 == tres14._2) ∧ (e34 == e37)) ∨ (((¬(ci43) ∧ (ci43 <=> t.isInstanceOf[Node])) ∨ (¬(ci44) ∧ (cs86 == t.left) ∧ (ci44 <=> cs86.isInstanceOf[Leaf])) ∨ (¬(ci45) ∧ (cs87 == t.right) ∧ (ci45 <=> cs87.isInstanceOf[Node]))) ∧ (ifres29 == tp39) ∧ (arg39 == (t38 + t51)) ∧ (tp39 == (e43, arg39)) ∧ (t52 == 4) ∧ ((ci46 ∧ (ci46 <=> t.isInstanceOf[Node]) ∧ ci47 ∧ (cs88 == t.left) ∧ (ci47 <=> cs88.isInstanceOf[Node]) ∧ (ifres30 == tp40) ∧ (arg40 == (t52 + t53)) ∧ (tp40 == (e45, arg40)) ∧ (t54 == (1 + (2 + (1 + t62)))) ∧ (t53 == (1 + (2 + (t54 + 1)))) ∧ (t62 == ts89) ∧ (ts89 == tres15._2) ∧ (e54 == ts90) ∧ (ts90 == tres15._1) ∧ (e45 == cc21) ∧ (cs89 == t.left) ∧ (cs90 == cs89.value) ∧ (cs91 == t.right) ∧ (cc21 == Node(e46, cs90, cs91)) ∧ (tres15 == r83) ∧ (cs92 == t.left) ∧ (cs93 == cs92.value) ∧ (cs94 == t.left) ∧ (r83 == remove1(cs93, cs94)) ∧ (e46 == e54)) ∨ (((¬(ci48) ∧ (ci48 <=> t.isInstanceOf[Node])) ∨ (¬(ci49) ∧ (cs95 == t.left) ∧ (ci49 <=> cs95.isInstanceOf[Node]))) ∧ (ifres30 == tp41) ∧ (cc22 == Leaf()) ∧ (arg41 == (t52 + 1)) ∧ (tp41 == (cc22, arg41)))) ∧ (e43 == ts91) ∧ (ts91 == ifres30._1) ∧ (t51 == ts92) ∧ (ts92 == ifres30._2))) ∧ (e29 == ts93) ∧ (ts93 == ifres29._1) ∧ (t37 == ts94) ∧ (ts94 == ifres29._2))) ∧ (e26 == ts95) ∧ (ts95 == ifres28._1) ∧ (t34 == ts96) ∧ (ts96 == ifres28._2))) ∧ (e14 == ts97) ∧ (ts97 == ifres27._1) ∧ (t22 == ts98) ∧ (ts98 == ifres27._2))) ∧ (e2 == ts99) ∧ (ts99 == ifres26._1) ∧ (t10 == ts100) ∧ (ts100 == ifres26._2))))
Flattened Post: ((ts101 > ((a?1 * r84) + b?1)) ∧ (ts101 == res3._2) ∧ (r84 == height1(t)))
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
remove1-->((((1 * res3._2) + (0 * height1(t))) + 0) ≤ 0)
Function: remove1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 61
[[34m Info  [0m] Number of equal calls: 10
# of atomic predicates: 13
solving...
solved... in 0.006s
candidate Invariants
remove1-->((((1 * res3._2) + (0 * height1(t))) + -14) ≤ 0)
Function: remove1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 39
[[34m Info  [0m] Number of equal calls: 9
# of atomic predicates: 12
solving...
solved... in 0.006s
[[34m Info  [0m] - More unrollings for invariant inference
Creating VC for height1
Unrolling (r85 == height1(cs68))
Unrolling (r84 == height1(t))
Unrolling (r86 == height1(cs73))
Unrolling (r80 == remove1(elem, cs68))
Unrolling (r88 == height1(cs94))
Unrolling (r83 == remove1(cs93, cs94))
Unrolling (r81 == remove1(elem, cs73))
Unrolling (r87 == height1(cs85))
Unrolling (r82 == remove1(cs84, cs85))
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
remove1-->((((0 * height1(t)) + (1 * res3._2)) + 0) ≤ 0)
height1-->(((0 * #res) + 0) ≤ 0)
Function: remove1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 73
[[34m Info  [0m] Number of equal calls: 13
# of atomic predicates: 19
solving...
solved... in 0.006s
candidate Invariants
remove1-->((((6 * height1(t)) + (16 * res3._2)) + -8) ≤ 0)
height1-->(((12 * #res) + 440) ≤ 0)
Function: remove1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 1141
[[34m Info  [0m] Number of equal calls: 52
Function: height1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 39
solving...
solved... in 0.011s
candidate Invariants
remove1-->((((-30 * height1(t)) + (1 * res3._2)) + -15) ≤ 0)
height1-->(((-1 * #res) + -1) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: remove1 --> ((((-30 * height1(t)) + (1 * res3._2)) + -15) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: height1 --> (((-1 * #res) + -1) ≤ 0)
[[34m Info  [0m] - Verifying Invariants... 
[[34m Info  [0m] - Invariant verified
Inferrence did not succeeded for functions: List()
[[34m Info  [0m] - Dumping statistics
[[34m Info  [0m] . ┌─────────┐
          ╔═╡ Summary ╞═══════════════════════════════════════════════════════════════════════╗
          ║ └─────────┘                                                                       ║
          
          ╟┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄╢
          ║ total: 0      valid: 0      invalid: 0      unknown 0                       0.000 ║
          ╚═══════════════════════════════════════════════════════════════════════════════════╝
