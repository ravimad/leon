New Prog: 
object BinaryTrie {
  sealed abstract class IList

  case class Nil() extends IList

  case class Node(nvalue: Int, left: Tree, right: Tree) extends Tree

  case class Leaf() extends Tree

  case class Cons(head: Int, tail: IList) extends IList

  sealed abstract class Tree

  def insert1(inp : IList, t : Tree) : (Tree, Int) = {locally {
    val t3 = 1
    if (t.isInstanceOf[Leaf]) {
      locally {
        val (e1: Tree, t4: Int) = locally {
          val t5 = 1
          if (inp.isInstanceOf[Nil]) {
            (t, t5)
          } else {
            locally {
              val (e4: Node, t7: Int) = locally {
                val (ir: Tree, it: Int) = locally {
                  val (e7: Tree, t11: Int) = insert1(inp.tail, Leaf())
                  (e7, (1 + (1 + (1 + t11))))
                }
                
                locally {
                  val (r3: Node, t8: Int) = locally {
                    val t13 = 1
                    if (ir.isInstanceOf[Leaf]) {
                      (Node(inp.head, Leaf(), Leaf()), (t13 + 4))
                    } else {
                      locally {
                        val (e15: Node, t19: Int) = locally {
                          val t20 = 2
                          if ((ir.nvalue > 0)) {
                            (Node(inp.head, ir, Leaf()), (t20 + 3))
                          } else {
                            (Node(ir.nvalue, Leaf(), ir), (t20 + 3))
                          }
                        }
                        
                        (e15, (t13 + t19))
                      }
                      
                    }
                  }
                  
                  (r3, (t8 + (it + 1)))
                }
                
              }
              
              (e4, (t5 + t7))
            }
            
          }
        }
        
        (e1, (t3 + t4))
      }
      
    } else {
      locally {
        val (e32: Tree, t36: Int) = locally {
          val t37 = 1
          if (inp.isInstanceOf[Nil]) {
            (t, t37)
          } else {
            locally {
              val (e35: Tree, t39: Int) = locally {
                val t40 = 4
                if ((inp.isInstanceOf[Cons] && inp.tail.isInstanceOf[Nil])) {
                  (t, t40)
                } else {
                  locally {
                    val (e38: Tree, t42: Int) = locally {
                      val t43 = 4
                      if ((inp.isInstanceOf[Cons] && inp.tail.isInstanceOf[Cons])) {
                        locally {
                          val (e40: Node, t44: Int) = locally {
                            val (ir1: Tree, it1: Int) = locally {
                              val t46 = 3
                              if ((inp.tail.head > 0)) {
                                (t.left, (t46 + 1))
                              } else {
                                (t.right, (t46 + 1))
                              }
                            }
                            
                            locally {
                              val (r4: Node, t45: Int) = locally {
                                val t55 = 3
                                if ((inp.tail.head > 0)) {
                                  locally {
                                    val (e51: Node, t56: Int) = locally {
                                      val (e53: Tree, t58: Int) = locally {
                                        val (e58: Tree, t63: Int) = insert1(inp.tail, ir1)
                                        (e58, (1 + (1 + t63)))
                                      }
                                      
                                      (Node(t.nvalue, e53, t.right), (1 + (t58 + 2)))
                                    }
                                    
                                    (e51, (t55 + t56))
                                  }
                                  
                                } else {
                                  locally {
                                    val (e61: Node, t66: Int) = locally {
                                      val (e64: Tree, t69: Int) = locally {
                                        val (e67: Tree, t72: Int) = insert1(inp.tail, ir1)
                                        (e67, (1 + (1 + t72)))
                                      }
                                      
                                      (Node(t.nvalue, t.left, e64), (t69 + 3))
                                    }
                                    
                                    (e61, (t55 + t66))
                                  }
                                  
                                }
                              }
                              
                              (r4, (t45 + (it1 + 1)))
                            }
                            
                          }
                          
                          (e40, (t43 + t44))
                        }
                        
                      } else {
                        (t, t43)
                      }
                    }
                    
                    (e38, (t40 + t42))
                  }
                  
                }
              }
              
              (e35, (t37 + t39))
            }
            
          }
        }
        
        (e32, (t3 + t36))
      }
      
    }
  }
  } ensuring(res3 => true)

  def create1(inp : IList) : (Tree, Int) = {locally {
    val (e131: Tree, t136: Int) = insert1(inp, Leaf())
    (e131, (1 + (1 + t136)))
  }
  } ensuring(res5 => true)

  def find1(inp : IList, t : Tree) : (Tree, Int) = {locally {
    val t93 = 1
    if (inp.isInstanceOf[Nil]) {
      (t, t93)
    } else {
      locally {
        val (e90: Tree, t95: Int) = locally {
          val t96 = 4
          if ((inp.isInstanceOf[Cons] && inp.tail.isInstanceOf[Nil])) {
            (t, t96)
          } else {
            locally {
              val (e93: Tree, t98: Int) = locally {
                val t99 = 4
                if ((inp.isInstanceOf[Cons] && inp.tail.isInstanceOf[Cons])) {
                  locally {
                    val (e95: Tree, t100: Int) = locally {
                      val t101 = 1
                      if (t.isInstanceOf[Leaf]) {
                        (t, t101)
                      } else {
                        locally {
                          val (e98: Tree, t103: Int) = locally {
                            val t104 = 3
                            if ((inp.tail.head > 0)) {
                              locally {
                                val (e100: Tree, t105: Int) = locally {
                                  val (e103: Tree, t108: Int) = find1(inp.tail, t.left)
                                  (e103, (1 + (1 + (1 + t108))))
                                }
                                
                                (e100, (t104 + t105))
                              }
                              
                            } else {
                              locally {
                                val (e106: Tree, t111: Int) = locally {
                                  val (e109: Tree, t114: Int) = find1(inp.tail, t.right)
                                  (e109, (1 + (1 + (1 + t114))))
                                }
                                
                                (e106, (t104 + t111))
                              }
                              
                            }
                          }
                          
                          (e98, (t101 + t103))
                        }
                        
                      }
                    }
                    
                    (e95, (t99 + t100))
                  }
                  
                } else {
                  (t, t99)
                }
              }
              
              (e93, (t96 + t98))
            }
            
          }
        }
        
        (e90, (t93 + t95))
      }
      
    }
  }
  } ensuring(res4 => true)

  def height1(t : Tree) : Int = {(t match {
    case Leaf() =>
      0
    case Node(x, l, r) =>
      locally {
        val hl = height1(l)
        locally {
          val hr = height1(r)
          if ((hl > hr)) {
            (hl + 1)
          } else {
            (hr + 1)
          }
        }
        
      }
      
  })}

  def listSize1(l : IList) : Int = {(l match {
    case Nil() =>
      0
    case Cons(x, xs) =>
      (1 + listSize1(xs))
  })}
}

[[34m Info  [0m] Running Invariant Inference Phase...
[[34m Info  [0m] Analysis Order: List(listSize1, insert1, create1, height1, find1)
[[34m Info  [0m] - considering function insert1...
[[34m Info  [0m] Body: if (t.isInstanceOf[Leaf])
            (let (e1,t4 := if (inp.isInstanceOf[Nil])
              (t, 1)
            else
              (let (e4,t7 := (let (ir,it := (let (e7,t11 := insert1(inp.tail, Leaf())) in
                (e7, (1 + (1 + (1 + t11)))))) in
                (let (r3,t8 := if (ir.isInstanceOf[Leaf])
                  (Node(inp.head, Leaf(), Leaf()), (1 + 4))
                else
                  (let (e15,t19 := if ((ir.nvalue > 0))
                    (Node(inp.head, ir, Leaf()), (2 + 3))
                  else
                    (Node(ir.nvalue, Leaf(), ir), (2 + 3))) in
                    (e15, (1 + t19)))) in
                  (r3, (t8 + (it + 1)))))) in
                (e4, (1 + t7)))) in
              (e1, (1 + t4)))
          else
            (let (e32,t36 := if (inp.isInstanceOf[Nil])
              (t, 1)
            else
              (let (e35,t39 := if ((inp.isInstanceOf[Cons] ∧ inp.tail.isInstanceOf[Nil]))
                (t, 4)
              else
                (let (e38,t42 := if ((inp.isInstanceOf[Cons] ∧ inp.tail.isInstanceOf[Cons]))
                  (let (e40,t44 := (let (ir1,it1 := if ((inp.tail.head > 0))
                    (t.left, (3 + 1))
                  else
                    (t.right, (3 + 1))) in
                    (let (r4,t45 := if ((inp.tail.head > 0))
                      (let (e51,t56 := (let (e53,t58 := (let (e58,t63 := insert1(inp.tail, ir1)) in
                        (e58, (1 + (1 + t63))))) in
                        (Node(t.nvalue, e53, t.right), (1 + (t58 + 2))))) in
                        (e51, (3 + t56)))
                    else
                      (let (e61,t66 := (let (e64,t69 := (let (e67,t72 := insert1(inp.tail, ir1)) in
                        (e67, (1 + (1 + t72))))) in
                        (Node(t.nvalue, t.left, e64), (t69 + 3)))) in
                        (e61, (3 + t66)))) in
                      (r4, (t45 + (it1 + 1)))))) in
                    (e40, (4 + t44)))
                else
                  (t, 4)) in
                  (e38, (4 + t42)))) in
                (e35, (1 + t39)))) in
              (e32, (1 + t36)))
[[34m Info  [0m] Post: true
falttened Body: ((res3 == ifres) ∧ (t3 == 1) ∧ ((ci ∧ (ci <=> t.isInstanceOf[Leaf]) ∧ (ifres == tp) ∧ (arg == (t3 + t4)) ∧ (tp == (e1, arg)) ∧ (t5 == 1) ∧ ((ci1 ∧ (ci1 <=> inp.isInstanceOf[Nil]) ∧ (ifres1 == tp1) ∧ (tp1 == (t, t5))) ∨ (¬(ci2) ∧ (ci2 <=> inp.isInstanceOf[Nil]) ∧ (ifres1 == tp2) ∧ (arg1 == (t5 + t7)) ∧ (tp2 == (e4, arg1)) ∧ (tres == r5) ∧ (cs == inp.tail) ∧ (cc == Leaf()) ∧ (r5 == insert1(cs, cc)) ∧ (ir == e7) ∧ (r3 == ts) ∧ (ts == ifres2._1) ∧ (t11 == ts1) ∧ (ts1 == tres._2) ∧ (it == (1 + (1 + (1 + t11)))) ∧ ((ci3 ∧ (ci3 <=> ir.isInstanceOf[Leaf]) ∧ (ifres2 == tp3) ∧ (cc1 == Leaf()) ∧ (tp3 == (cc3, arg2)) ∧ (cc3 == Node(cs1, cc1, cc2)) ∧ (cs1 == inp.head) ∧ (cc2 == Leaf()) ∧ (arg2 == (t13 + 4))) ∨ (¬(ci4) ∧ (ci4 <=> ir.isInstanceOf[Leaf]) ∧ (ifres2 == tp4) ∧ (arg3 == (t13 + t19)) ∧ (tp4 == (e15, arg3)) ∧ (t20 == 2) ∧ (((cs2 > 0) ∧ (cs2 == ir.nvalue) ∧ (ifres3 == tp5) ∧ (cc5 == Node(cs3, ir, cc4)) ∧ (tp5 == (cc5, arg4)) ∧ (arg4 == (t20 + 3)) ∧ (cc4 == Leaf()) ∧ (cs3 == inp.head)) ∨ ((cs4 ≤ 0) ∧ (cs4 == ir.nvalue) ∧ (ifres3 == tp6) ∧ (tp6 == (cc7, arg5)) ∧ (cs5 == ir.nvalue) ∧ (cc6 == Leaf()) ∧ (cc7 == Node(cs5, cc6, ir)) ∧ (arg5 == (t20 + 3)))) ∧ (e15 == ts2) ∧ (ts2 == ifres3._1) ∧ (t19 == ts3) ∧ (ts3 == ifres3._2))) ∧ (t7 == (t8 + (it + 1))) ∧ (t13 == 1) ∧ (e7 == ts4) ∧ (ts4 == tres._1) ∧ (t8 == ts5) ∧ (ts5 == ifres2._2) ∧ (e4 == r3))) ∧ (e1 == ts6) ∧ (ts6 == ifres1._1) ∧ (t4 == ts7) ∧ (ts7 == ifres1._2)) ∨ (¬(ci5) ∧ (ci5 <=> t.isInstanceOf[Leaf]) ∧ (ifres == tp7) ∧ (arg6 == (t3 + t36)) ∧ (tp7 == (e32, arg6)) ∧ (t37 == 1) ∧ ((ci6 ∧ (ci6 <=> inp.isInstanceOf[Nil]) ∧ (ifres4 == tp8) ∧ (tp8 == (t, t37))) ∨ (¬(ci7) ∧ (ci7 <=> inp.isInstanceOf[Nil]) ∧ (ifres4 == tp9) ∧ (arg7 == (t37 + t39)) ∧ (tp9 == (e35, arg7)) ∧ (t40 == 4) ∧ ((ci8 ∧ (ci8 <=> inp.isInstanceOf[Cons]) ∧ ci9 ∧ (cs6 == inp.tail) ∧ (ci9 <=> cs6.isInstanceOf[Nil]) ∧ (ifres5 == tp10) ∧ (tp10 == (t, t40))) ∨ (((¬(ci10) ∧ (ci10 <=> inp.isInstanceOf[Cons])) ∨ (¬(ci11) ∧ (cs7 == inp.tail) ∧ (ci11 <=> cs7.isInstanceOf[Nil]))) ∧ (ifres5 == tp11) ∧ (arg8 == (t40 + t42)) ∧ (tp11 == (e38, arg8)) ∧ (t43 == 4) ∧ ((ci12 ∧ (ci12 <=> inp.isInstanceOf[Cons]) ∧ ci13 ∧ (cs8 == inp.tail) ∧ (ci13 <=> cs8.isInstanceOf[Cons]) ∧ (ifres6 == tp12) ∧ (arg9 == (t43 + t44)) ∧ (tp12 == (e40, arg9)) ∧ (it1 == ts8) ∧ (ts8 == ifres8._2) ∧ (t55 == 3) ∧ (t46 == 3) ∧ (r4 == ts9) ∧ (ts9 == ifres7._1) ∧ (((cs10 > 0) ∧ (cs9 == inp.tail) ∧ (cs10 == cs9.head) ∧ (ifres7 == tp13) ∧ (arg10 == (t55 + t56)) ∧ (tp13 == (e51, arg10)) ∧ (tres1 == r6) ∧ (cs11 == inp.tail) ∧ (r6 == insert1(cs11, ir1)) ∧ (e53 == e58) ∧ (t56 == (1 + (t58 + 2))) ∧ (e51 == cc8) ∧ (cs12 == t.nvalue) ∧ (cs13 == t.right) ∧ (cc8 == Node(cs12, e53, cs13)) ∧ (t63 == ts10) ∧ (ts10 == tres1._2) ∧ (e58 == ts11) ∧ (ts11 == tres1._1) ∧ (t58 == (1 + (1 + t63)))) ∨ ((cs15 ≤ 0) ∧ (cs14 == inp.tail) ∧ (cs15 == cs14.head) ∧ (ifres7 == tp14) ∧ (arg11 == (t55 + t66)) ∧ (tp14 == (e61, arg11)) ∧ (e67 == ts12) ∧ (ts12 == tres2._1) ∧ (e61 == cc9) ∧ (cs16 == t.nvalue) ∧ (cs17 == t.left) ∧ (cc9 == Node(cs16, cs17, e64)) ∧ (t69 == (1 + (1 + t72))) ∧ (tres2 == r7) ∧ (cs18 == inp.tail) ∧ (r7 == insert1(cs18, ir1)) ∧ (t72 == ts13) ∧ (ts13 == tres2._2) ∧ (e64 == e67) ∧ (t66 == (t69 + 3)))) ∧ (t44 == (t45 + (it1 + 1))) ∧ (ir1 == ts14) ∧ (ts14 == ifres8._1) ∧ (((cs20 > 0) ∧ (cs19 == inp.tail) ∧ (cs20 == cs19.head) ∧ (ifres8 == tp15) ∧ (cs21 == t.left) ∧ (arg12 == (t46 + 1)) ∧ (tp15 == (cs21, arg12))) ∨ ((cs23 ≤ 0) ∧ (cs22 == inp.tail) ∧ (cs23 == cs22.head) ∧ (ifres8 == tp16) ∧ (cs24 == t.right) ∧ (arg13 == (t46 + 1)) ∧ (tp16 == (cs24, arg13)))) ∧ (t45 == ts15) ∧ (ts15 == ifres7._2) ∧ (e40 == r4)) ∨ (((¬(ci14) ∧ (ci14 <=> inp.isInstanceOf[Cons])) ∨ (¬(ci15) ∧ (cs25 == inp.tail) ∧ (ci15 <=> cs25.isInstanceOf[Cons]))) ∧ (ifres6 == tp17) ∧ (tp17 == (t, t43)))) ∧ (e38 == ts16) ∧ (ts16 == ifres6._1) ∧ (t42 == ts17) ∧ (ts17 == ifres6._2))) ∧ (e35 == ts18) ∧ (ts18 == ifres5._1) ∧ (t39 == ts19) ∧ (ts19 == ifres5._2))) ∧ (e32 == ts20) ∧ (ts20 == ifres4._1) ∧ (t36 == ts21) ∧ (ts21 == ifres4._2))))
Flattened Post: ((ts22 > ((a?1 * r8) + c?1)) ∧ (ts22 == res3._2) ∧ (r8 == listSize1(inp)))
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
insert1-->((((1 * res3._2) + (0 * listSize1(inp))) + 0) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 28
[[34m Info  [0m] Number of equal calls: 5
# of atomic predicates: 9
solving...
solved... in 0.01s
candidate Invariants
insert1-->((((0 * listSize1(inp)) + (1 * res3._2)) + -8) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 218
[[34m Info  [0m] Number of equal calls: 21
# of atomic predicates: 12
solving...
solved... in 0.006s
[[34m Info  [0m] - More unrollings for invariant inference
Unrolling (r6 == insert1(cs11, ir1))
Unrolling (r5 == insert1(cs, cc))
Creating VC for listSize1
[[34m Info  [0m] - Number of new terms enumerated: 2
[[34m Info  [0m] - Template generated for function listSize1 : (((a?4 * #res) + a?3) ≤ 0)
Unrolling (r9 == listSize1(cs))
Unrolling (r10 == listSize1(cs11))
Unrolling (r11 == listSize1(cs18))
Unrolling (r7 == insert1(cs18, ir1))
Unrolling (r8 == listSize1(inp))
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
insert1-->((((0 * listSize1(inp)) + (1 * res3._2)) + 0) ≤ 0)
listSize1-->(((0 * #res) + 0) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 900
[[34m Info  [0m] Number of equal calls: 47
# of atomic predicates: 21
solving...
solved... in 0.008s
candidate Invariants
insert1-->((((-2 * listSize1(inp)) + (16 * res3._2)) + -8) ≤ 0)
listSize1-->(((0 * #res) + 565) ≤ 0)
Function: listSize1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 8
solving...
solved... in 0.007s
candidate Invariants
insert1-->((((-50 * listSize1(inp)) + (2 * res3._2)) + -1) ≤ 0)
listSize1-->(((0 * #res) + -1) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 30
[[34m Info  [0m] Number of equal calls: 6
# of atomic predicates: 12
solving...
solved... in 0.009s
candidate Invariants
insert1-->((((-47 * listSize1(inp)) + (2 * res3._2)) + -64) ≤ 0)
listSize1-->(((-1 * #res) + -2) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: insert1 --> ((((2 * res3._2) + (-47 * listSize1(inp))) + -64) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: listSize1 --> (((-1 * #res) + -2) ≤ 0)
[[34m Info  [0m] - Verifying Invariants... 
[[34m Info  [0m] - Invariant verified
[[34m Info  [0m] - considering function create1...
[[34m Info  [0m] Body: (let (e131,t136 := insert1(inp, Leaf())) in
            (e131, (1 + (1 + t136))))
[[34m Info  [0m] Post: true
falttened Body: ((res5 == tp72) ∧ (arg56 == (1 + (1 + t136))) ∧ (tp72 == (e131, arg56)) ∧ (tres12 == r48) ∧ (cc40 == Leaf()) ∧ (r48 == insert1(inp, cc40)) ∧ (e131 == ts108) ∧ (ts108 == tres12._1) ∧ (t136 == ts109) ∧ (ts109 == tres12._2))
Flattened Post: ((ts110 > ((a?2 * r49) + c?2)) ∧ (ts110 == res5._2) ∧ (r49 == listSize1(inp)))
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
create1-->((((0 * listSize1(inp)) + (1 * res5._2)) + 0) ≤ 0)
Function: create1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 6
[[34m Info  [0m] Number of equal calls: 2
# of atomic predicates: 9
solving...
solved... in 0.004s
[[34m Info  [0m] - More unrollings for invariant inference
Creating VC for insert1
Unrolling (r48 == insert1(inp, cc40))
Creating VC for listSize1
Unrolling (r49 == listSize1(inp))
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
create1-->((((1 * res5._2) + (0 * listSize1(inp))) + 0) ≤ 0)
insert1-->((((1 * res3._2) + (0 * listSize1(inp))) + 0) ≤ 0)
listSize1-->(((0 * #res) + 0) ≤ 0)
Function: create1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 167
[[34m Info  [0m] Number of equal calls: 18
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 28
[[34m Info  [0m] Number of equal calls: 5
# of atomic predicates: 28
solving...
solved... in 0.007s
candidate Invariants
create1-->((((288 * listSize1(inp)) + (512 * res5._2)) + -4816) ≤ 0)
insert1-->((((8 * listSize1(inp)) + (16 * res3._2)) + -2) ≤ 0)
listSize1-->(((2 * #res) + 32) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 218
[[34m Info  [0m] Number of equal calls: 21
Function: listSize1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 23
solving...
solved... in 0.009s
candidate Invariants
create1-->((((2 * res5._2) + (-1 * listSize1(inp))) + -18) ≤ 0)
insert1-->((((-1 * listSize1(inp)) + (2 * res3._2)) + 1) ≤ 0)
listSize1-->(((0 * #res) + 1) ≤ 0)
Function: listSize1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 8
solving...
solved... in 0.01s
[[34m Info  [0m] - More unrollings for invariant inference
Unrolling (r69 == listSize1(cs122))
Unrolling (r62 == listSize1(cs161))
Unrolling (r63 == listSize1(cs162))
Unrolling (r56 == listSize1(inp))
Unrolling (r55 == insert1(cs127, ir9))
Unrolling (r67 == listSize1(inp))
Unrolling (r70 == listSize1(cs127))
Unrolling (r61 == insert1(cs157, ir11))
Unrolling (r60 == insert1(cs152, ir11))
Unrolling (r54 == insert1(cs122, ir9))
Unrolling (r65 == listSize1(cs152))
Unrolling (r64 == listSize1(cs140))
Unrolling (r68 == listSize1(cs109))
Unrolling (r59 == insert1(cs140, cc58))
Unrolling (r53 == insert1(cs109, cc41))
Unrolling (r66 == listSize1(cs157))
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
create1-->((((0 * listSize1(inp)) + (1 * res5._2)) + 0) ≤ 0)
insert1-->((((1 * res3._2) + (0 * listSize1(inp))) + 0) ≤ 0)
listSize1-->(((0 * #res) + 0) ≤ 0)
Function: create1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 455
[[34m Info  [0m] Number of equal calls: 36
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 900
[[34m Info  [0m] Number of equal calls: 47
# of atomic predicates: 50
solving...
solved... in 0.01s
candidate Invariants
create1-->((((8 * res5._2) + (-185 * listSize1(inp))) + 125) ≤ 0)
insert1-->((((1 * res3._2) + (-24 * listSize1(inp))) + -1) ≤ 0)
listSize1-->(((2 * #res) + -8) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 30
[[34m Info  [0m] Number of equal calls: 6
Function: listSize1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 2
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 24
solving...
solved... in 0.013s
candidate Invariants
create1-->((((1 * res5._2) + (-31 * listSize1(inp))) + 14) ≤ 0)
insert1-->((((-24 * listSize1(inp)) + (1 * res3._2)) + -7) ≤ 0)
listSize1-->(((-1 * #res) + -1) ≤ 0)
Function: create1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 37
[[34m Info  [0m] Number of equal calls: 7
# of atomic predicates: 14
solving...
solved... in 0.017s
candidate Invariants
create1-->((((-62 * listSize1(inp)) + (2 * res5._2)) + 1) ≤ 0)
insert1-->((((4 * res3._2) + (-96 * listSize1(inp))) + -1) ≤ 0)
listSize1-->(((-4 * #res) + -1) ≤ 0)
Function: insert1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 10
[[34m Info  [0m] Number of equal calls: 3
# of atomic predicates: 10
solving...
solved... in 0.017s
candidate Invariants
create1-->((((4 * res5._2) + (-124 * listSize1(inp))) + 1) ≤ 0)
insert1-->((((2 * res3._2) + (-48 * listSize1(inp))) + 1) ≤ 0)
listSize1-->(((-8 * #res) + 1) ≤ 0)
Function: listSize1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 8
solving...
solved... in 0.02s
candidate Invariants
create1-->((((-1516729 * listSize1(inp)) + (65536 * res5._2)) + -9699328) ≤ 0)
insert1-->((((8 * res3._2) + (-185 * listSize1(inp))) + -1344) ≤ 0)
listSize1-->(((-1 * #res) + -8) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: create1 --> ((((-1516729 * listSize1(inp)) + (65536 * res5._2)) + -9699328) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: insert1 --> ((((-185 * listSize1(inp)) + (8 * res3._2)) + -1344) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: listSize1 --> (((-1 * #res) + -8) ≤ 0)
[[34m Info  [0m] - Verifying Invariants... 
[[34m Info  [0m] - Invariant verified
[[34m Info  [0m] - considering function find1...
[[34m Info  [0m] Body: if (inp.isInstanceOf[Nil])
            (t, 1)
          else
            (let (e90,t95 := if ((inp.isInstanceOf[Cons] ∧ inp.tail.isInstanceOf[Nil]))
              (t, 4)
            else
              (let (e93,t98 := if ((inp.isInstanceOf[Cons] ∧ inp.tail.isInstanceOf[Cons]))
                (let (e95,t100 := if (t.isInstanceOf[Leaf])
                  (t, 1)
                else
                  (let (e98,t103 := if ((inp.tail.head > 0))
                    (let (e100,t105 := (let (e103,t108 := find1(inp.tail, t.left)) in
                      (e103, (1 + (1 + (1 + t108)))))) in
                      (e100, (3 + t105)))
                  else
                    (let (e106,t111 := (let (e109,t114 := find1(inp.tail, t.right)) in
                      (e109, (1 + (1 + (1 + t114)))))) in
                      (e106, (3 + t111)))) in
                    (e98, (1 + t103)))) in
                  (e95, (4 + t100)))
              else
                (t, 4)) in
                (e93, (4 + t98)))) in
              (e90, (1 + t95)))
[[34m Info  [0m] Post: true
falttened Body: ((res4 == ifres108) ∧ (t93 == 1) ∧ ((ci226 ∧ (ci226 <=> inp.isInstanceOf[Nil]) ∧ (ifres108 == tp217) ∧ (tp217 == (t, t93))) ∨ (¬(ci227) ∧ (ci227 <=> inp.isInstanceOf[Nil]) ∧ (ifres108 == tp218) ∧ (arg169 == (t93 + t95)) ∧ (tp218 == (e90, arg169)) ∧ (t96 == 4) ∧ ((ci228 ∧ (ci228 <=> inp.isInstanceOf[Cons]) ∧ ci229 ∧ (cs329 == inp.tail) ∧ (ci229 <=> cs329.isInstanceOf[Nil]) ∧ (ifres109 == tp219) ∧ (tp219 == (t, t96))) ∨ (((¬(ci230) ∧ (ci230 <=> inp.isInstanceOf[Cons])) ∨ (¬(ci231) ∧ (cs330 == inp.tail) ∧ (ci231 <=> cs330.isInstanceOf[Nil]))) ∧ (ifres109 == tp220) ∧ (arg170 == (t96 + t98)) ∧ (tp220 == (e93, arg170)) ∧ (t99 == 4) ∧ ((ci232 ∧ (ci232 <=> inp.isInstanceOf[Cons]) ∧ ci233 ∧ (cs331 == inp.tail) ∧ (ci233 <=> cs331.isInstanceOf[Cons]) ∧ (ifres110 == tp221) ∧ (arg171 == (t99 + t100)) ∧ (tp221 == (e95, arg171)) ∧ (t101 == 1) ∧ ((ci234 ∧ (ci234 <=> t.isInstanceOf[Leaf]) ∧ (ifres111 == tp222) ∧ (tp222 == (t, t101))) ∨ (¬(ci235) ∧ (ci235 <=> t.isInstanceOf[Leaf]) ∧ (ifres111 == tp223) ∧ (arg172 == (t101 + t103)) ∧ (tp223 == (e98, arg172)) ∧ (t104 == 3) ∧ (((cs333 > 0) ∧ (cs332 == inp.tail) ∧ (cs333 == cs332.head) ∧ (ifres112 == tp224) ∧ (arg173 == (t104 + t105)) ∧ (tp224 == (e100, arg173)) ∧ (tres37 == r149) ∧ (cs334 == inp.tail) ∧ (cs335 == t.left) ∧ (r149 == find1(cs334, cs335)) ∧ (e103 == ts334) ∧ (ts334 == tres37._1) ∧ (t105 == (1 + (1 + (1 + t108)))) ∧ (t108 == ts335) ∧ (ts335 == tres37._2) ∧ (e100 == e103)) ∨ ((cs337 ≤ 0) ∧ (cs336 == inp.tail) ∧ (cs337 == cs336.head) ∧ (ifres112 == tp225) ∧ (arg174 == (t104 + t111)) ∧ (tp225 == (e106, arg174)) ∧ (t111 == (1 + (1 + (1 + t114)))) ∧ (e109 == ts336) ∧ (ts336 == tres38._1) ∧ (e106 == e109) ∧ (tres38 == r150) ∧ (cs338 == inp.tail) ∧ (cs339 == t.right) ∧ (r150 == find1(cs338, cs339)) ∧ (t114 == ts337) ∧ (ts337 == tres38._2))) ∧ (e98 == ts338) ∧ (ts338 == ifres112._1) ∧ (t103 == ts339) ∧ (ts339 == ifres112._2))) ∧ (e95 == ts340) ∧ (ts340 == ifres111._1) ∧ (t100 == ts341) ∧ (ts341 == ifres111._2)) ∨ (((¬(ci236) ∧ (ci236 <=> inp.isInstanceOf[Cons])) ∨ (¬(ci237) ∧ (cs340 == inp.tail) ∧ (ci237 <=> cs340.isInstanceOf[Cons]))) ∧ (ifres110 == tp226) ∧ (tp226 == (t, t99)))) ∧ (e93 == ts342) ∧ (ts342 == ifres110._1) ∧ (t98 == ts343) ∧ (ts343 == ifres110._2))) ∧ (e90 == ts344) ∧ (ts344 == ifres109._1) ∧ (t95 == ts345) ∧ (ts345 == ifres109._2))))
Flattened Post: ((ts346 > ((a? * r151) + c?)) ∧ (ts346 == res4._2) ∧ (r151 == listSize1(inp)))
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
find1-->((((0 * listSize1(inp)) + (1 * res4._2)) + 0) ≤ 0)
Function: find1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 10
[[34m Info  [0m] Number of equal calls: 3
# of atomic predicates: 9
solving...
solved... in 0.005s
candidate Invariants
find1-->((((1 * res4._2) + (0 * listSize1(inp))) + -7) ≤ 0)
Function: find1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 147
[[34m Info  [0m] Number of equal calls: 14
# of atomic predicates: 12
solving...
solved... in 0.005s
[[34m Info  [0m] - More unrollings for invariant inference
Unrolling (r150 == find1(cs338, cs339))
Creating VC for listSize1
Unrolling (r152 == listSize1(cs334))
Unrolling (r153 == listSize1(cs338))
Unrolling (r151 == listSize1(inp))
Unrolling (r149 == find1(cs334, cs335))
[[34m Info  [0m] Number of axiom instances: 0
[[34m Info  [0m] Number of axiom instances: 0
candidate Invariants
find1-->((((1 * res4._2) + (0 * listSize1(inp))) + 0) ≤ 0)
listSize1-->(((0 * #res) + 0) ≤ 0)
Function: find1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 12
[[34m Info  [0m] Number of equal calls: 4
# of atomic predicates: 12
solving...
solved... in 0.005s
candidate Invariants
find1-->((((2 * listSize1(inp)) + (8 * res4._2)) + -4) ≤ 0)
listSize1-->(((16 * #res) + 424) ≤ 0)
Function: find1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 244
[[34m Info  [0m] Number of equal calls: 21
Function: listSize1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 28
solving...
solved... in 0.01s
candidate Invariants
find1-->((((-15 * listSize1(inp)) + (1 * res4._2)) + -1) ≤ 0)
listSize1-->(((-2 * #res) + -1) ≤ 0)
Function: find1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 606
[[34m Info  [0m] Number of equal calls: 33
# of atomic predicates: 21
solving...
solved... in 0.015s
candidate Invariants
find1-->((((1 * res4._2) + (-17 * listSize1(inp))) + 28) ≤ 0)
listSize1-->(((-1 * #res) + 1) ≤ 0)
Function: find1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 59
[[34m Info  [0m] Number of equal calls: 9
Function: listSize1--Found candidate invariant is not a real invariant! 
[[34m Info  [0m] Number of compatible calls: 0
[[34m Info  [0m] Number of equal calls: 0
# of atomic predicates: 20
solving...
solved... in 0.018s
candidate Invariants
find1-->((((-17 * listSize1(inp)) + (1 * res4._2)) + -11) ≤ 0)
listSize1-->(((-1 * #res) + -1) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: find1 --> ((((1 * res4._2) + (-17 * listSize1(inp))) + -11) ≤ 0)
[[34m Info  [0m] - Found inductive invariant: listSize1 --> (((-1 * #res) + -1) ≤ 0)
[[34m Info  [0m] - Verifying Invariants... 
[[34m Info  [0m] - Invariant verified
Inferrence did not succeeded for functions: List()
[[34m Info  [0m] - Dumping statistics
[[34m Info  [0m] . ┌─────────┐
          ╔═╡ Summary ╞═══════════════════════════════════════════════════════════════════════╗
          ║ └─────────┘                                                                       ║
          
          ╟┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄╢
          ║ total: 0      valid: 0      invalid: 0      unknown 0                       0.000 ║
          ╚═══════════════════════════════════════════════════════════════════════════════════╝
